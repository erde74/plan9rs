/* automatically generated by rust-bindgen 0.55.1 */

pub const JMPBUFSP: u32 = 0;
pub const JMPBUFPC: u32 = 1;
pub const JMPBUFDPC: u32 = 0;
pub const FPFTZ: u32 = 32768;
pub const FPINEX: u32 = 4096;
pub const FPUNFL: u32 = 2048;
pub const FPOVFL: u32 = 1024;
pub const FPZDIV: u32 = 512;
pub const FPDNRM: u32 = 256;
pub const FPINVAL: u32 = 128;
pub const FPDAZ: u32 = 64;
pub const FPRNR: u32 = 0;
pub const FPRZ: u32 = 24576;
pub const FPRPINF: u32 = 16384;
pub const FPRNINF: u32 = 8192;
pub const FPRMASK: u32 = 24576;
pub const FPPEXT: u32 = 0;
pub const FPPSGL: u32 = 0;
pub const FPPDBL: u32 = 0;
pub const FPPMASK: u32 = 0;
pub const FPAINEX: u32 = 32;
pub const FPAUNFL: u32 = 16;
pub const FPAOVFL: u32 = 8;
pub const FPAZDIV: u32 = 4;
pub const FPADNRM: u32 = 2;
pub const FPAINVAL: u32 = 1;
pub const MORDER: u32 = 3;
pub const MREPL: u32 = 0;
pub const MBEFORE: u32 = 1;
pub const MAFTER: u32 = 2;
pub const MCREATE: u32 = 4;
pub const MCACHE: u32 = 16;
pub const MMASK: u32 = 23;
pub const OREAD: u32 = 0;
pub const OWRITE: u32 = 1;
pub const ORDWR: u32 = 2;
pub const OEXEC: u32 = 3;
pub const OTRUNC: u32 = 16;
pub const OCEXEC: u32 = 32;
pub const ORCLOSE: u32 = 64;
pub const OEXCL: u32 = 4096;
pub const NCONT: u32 = 0;
pub const NDFLT: u32 = 1;
pub const NSAVE: u32 = 2;
pub const NRSTR: u32 = 3;
pub const ERRMAX: u32 = 128;
pub const KNAMELEN: u32 = 28;
pub const QTDIR: u32 = 128;
pub const QTAPPEND: u32 = 64;
pub const QTEXCL: u32 = 32;
pub const QTMOUNT: u32 = 16;
pub const QTAUTH: u32 = 8;
pub const QTFILE: u32 = 0;
pub const DMDIR: u32 = 2147483648;
pub const DMAPPEND: u32 = 1073741824;
pub const DMEXCL: u32 = 536870912;
pub const DMMOUNT: u32 = 268435456;
pub const DMREAD: u32 = 4;
pub const DMWRITE: u32 = 2;
pub const DMEXEC: u32 = 1;
pub const KiB: u32 = 1024;
pub const MiB: u32 = 1048576;
pub const GiB: u32 = 1073741824;
pub const TiB: u64 = 1099511627776;
pub const PiB: u64 = 1125899906842624;
pub const EiB: u64 = 1152921504606846976;
pub const BI2BY: u32 = 8;
pub const BY2V: u32 = 8;
pub const BY2SE: u32 = 8;
pub const BLOCKALIGN: u32 = 8;
pub const PGSZ: u32 = 4096;
pub const PGSHFT: u32 = 12;
pub const PTSZ: u32 = 4096;
pub const PTSHFT: u32 = 9;
pub const MACHSZ: u32 = 4096;
pub const MACHMAX: u32 = 32;
pub const MACHSTKSZ: u32 = 24576;
pub const KSTACK: u32 = 16384;
pub const HZ: u32 = 100;
pub const MS2HZ: u32 = 10;
pub const UTZERO: u32 = 2097152;
pub const USTKTOP: u64 = 140737488351232;
pub const USTKSIZE: u32 = 16777216;
pub const TSTKTOP: u64 = 140737471574016;
pub const KSEG0: i32 = -268435456;
pub const KSEG1: i64 = -1099511627776;
pub const KSEG2: i64 = -2199023255552;
pub const PMAPADDR: i32 = -2097152;
pub const KZERO: i32 = -268435456;
pub const KTZERO: i32 = -267321344;
pub const PTEPERTAB: u32 = 256;
pub const PTEMAPMEM: u32 = 1048576;
pub const SEGMAPSIZE: u32 = 65536;
pub const SSEGMAPSIZE: u32 = 16;
pub const PTEVALID: u32 = 1;
pub const PTEWRITE: u32 = 2;
pub const PTERONLY: u32 = 0;
pub const PTEUSER: u32 = 4;
pub const PTEUNCACHED: u32 = 16;
pub const TMFM: u32 = 234881024;
pub const KVATOP: i64 = -2199023255552;
pub const MAXSYSARG: u32 = 5;
pub const NCOLOR: u32 = 8;
pub const SEGMAXSIZE: u64 = 68719476736;
pub const NOCOLOR: i32 = -1;
pub const DEVDOTDOT: i32 = -1;
pub const NISAOPT: u32 = 8;
pub const DBGFLG: u32 = 0;
pub type ushort = ::std::os::raw::c_ushort;
pub type uchar = ::std::os::raw::c_uchar;
pub type ulong = ::std::os::raw::c_ulong;
pub type uint = ::std::os::raw::c_uint;
pub type schar = ::std::os::raw::c_schar;
pub type vlong = ::std::os::raw::c_longlong;
pub type uvlong = ::std::os::raw::c_ulonglong;
pub type uintptr = ::std::os::raw::c_ulonglong;
pub type usize_ = ::std::os::raw::c_ulong;
pub type Rune = uint;
pub type jmp_buf = [uintptr; 2usize];
pub type mpdigit = ::std::os::raw::c_uint;
pub type u8int = ::std::os::raw::c_uchar;
pub type u16int = ::std::os::raw::c_ushort;
pub type u32int = ::std::os::raw::c_uint;
pub type u64int = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union FPdbleword {
    pub x: f64,
    pub __bindgen_anon_1: FPdbleword__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPdbleword__bindgen_ty_1 {
    pub lo: uint,
    pub hi: uint,
}
#[test]
fn bindgen_test_layout_FPdbleword__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FPdbleword__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(FPdbleword__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FPdbleword__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(FPdbleword__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FPdbleword__bindgen_ty_1>())).lo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPdbleword__bindgen_ty_1),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FPdbleword__bindgen_ty_1>())).hi as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPdbleword__bindgen_ty_1),
            "::",
            stringify!(hi)
        )
    );
}
#[test]
fn bindgen_test_layout_FPdbleword() {
    assert_eq!(
        ::core::mem::size_of::<FPdbleword>(),
        8usize,
        concat!("Size of: ", stringify!(FPdbleword))
    );
    assert_eq!(
        ::core::mem::align_of::<FPdbleword>(),
        8usize,
        concat!("Alignment of ", stringify!(FPdbleword))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FPdbleword>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPdbleword),
            "::",
            stringify!(x)
        )
    );
}
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn memccpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_void,
        arg3: ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_void,
        arg3: ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memchr(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strecpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strrchr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cistrncmp(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cistrcmp(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tokenize(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const UTFmax: ::std::os::raw::c_uint = 4;
pub const Runesync: ::std::os::raw::c_uint = 128;
pub const Runeself: ::std::os::raw::c_uint = 128;
pub const Runeerror: ::std::os::raw::c_uint = 65533;
pub const Runemax: ::std::os::raw::c_uint = 1114111;
pub const Runemask: ::std::os::raw::c_uint = 2097151;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub fn runetochar(arg1: *mut ::std::os::raw::c_char, arg2: *mut Rune) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chartorune(arg1: *mut Rune, arg2: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn runelen(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fullrune(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utflen(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utfnlen(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utfrune(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn malloc(arg1: ::std::os::raw::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mallocz(arg1: ulong, arg2: ::std::os::raw::c_int) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn mallocalign(
        arg1: ulong,
        arg2: ulong,
        arg3: ::std::os::raw::c_long,
        arg4: ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn setmalloctag(arg1: *mut ::core::ffi::c_void, arg2: ulong);
}
extern "C" {
    pub fn setrealloctag(arg1: *mut ::core::ffi::c_void, arg2: ulong);
}
extern "C" {
    pub fn getmalloctag(arg1: *mut ::core::ffi::c_void) -> ulong;
}
extern "C" {
    pub fn getrealloctag(arg1: *mut ::core::ffi::c_void) -> ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fmt {
    pub runes: uchar,
    pub start: *mut ::core::ffi::c_void,
    pub to: *mut ::core::ffi::c_void,
    pub stop: *mut ::core::ffi::c_void,
    pub flush:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Fmt) -> ::std::os::raw::c_int>,
    pub farg: *mut ::core::ffi::c_void,
    pub nfmt: ::std::os::raw::c_int,
    pub args: va_list,
    pub r: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub prec: ::std::os::raw::c_int,
    pub flags: ulong,
}
#[test]
fn bindgen_test_layout_Fmt() {
    assert_eq!(
        ::core::mem::size_of::<Fmt>(),
        88usize,
        concat!("Size of: ", stringify!(Fmt))
    );
    assert_eq!(
        ::core::mem::align_of::<Fmt>(),
        8usize,
        concat!("Alignment of ", stringify!(Fmt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).runes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Fmt),
            "::",
            stringify!(runes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Fmt),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).to as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Fmt), "::", stringify!(to))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).stop as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Fmt), "::", stringify!(stop))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).flush as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Fmt),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).farg as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(Fmt), "::", stringify!(farg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).nfmt as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(Fmt), "::", stringify!(nfmt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).args as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Fmt), "::", stringify!(args))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).r as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(Fmt), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).width as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(Fmt),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).prec as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(Fmt), "::", stringify!(prec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fmt>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Fmt),
            "::",
            stringify!(flags)
        )
    );
}
pub const FmtWidth: ::std::os::raw::c_uint = 1;
pub const FmtLeft: ::std::os::raw::c_uint = 2;
pub const FmtPrec: ::std::os::raw::c_uint = 4;
pub const FmtSharp: ::std::os::raw::c_uint = 8;
pub const FmtSpace: ::std::os::raw::c_uint = 16;
pub const FmtSign: ::std::os::raw::c_uint = 32;
pub const FmtZero: ::std::os::raw::c_uint = 64;
pub const FmtUnsigned: ::std::os::raw::c_uint = 128;
pub const FmtShort: ::std::os::raw::c_uint = 256;
pub const FmtLong: ::std::os::raw::c_uint = 512;
pub const FmtVLong: ::std::os::raw::c_uint = 1024;
pub const FmtComma: ::std::os::raw::c_uint = 2048;
pub const FmtByte: ::std::os::raw::c_uint = 4096;
pub const FmtFlag: ::std::os::raw::c_uint = 8192;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
extern "C" {
    pub fn print(arg1: *mut ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seprint(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vseprint(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn snprint(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprint(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprint(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmtinstall(
        arg1: ::std::os::raw::c_int,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Fmt) -> ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmtprint(
        arg1: *mut Fmt,
        arg2: *mut ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmtstrcpy(arg1: *mut Fmt, arg2: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmtstrflush(arg1: *mut Fmt) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtstrinit(arg1: *mut Fmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quotefmtinstall();
}
extern "C" {
    pub fn cycles(arg1: *mut uvlong);
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atoi(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cleanname(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dec64(
        arg1: *mut uchar,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcallerpc(arg1: *mut ::core::ffi::c_void) -> uintptr;
}
extern "C" {
    pub fn getfields(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettokens(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_long,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn strtol(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ulong;
}
extern "C" {
    pub fn strtoll(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> vlong;
}
extern "C" {
    pub fn strtoull(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> uvlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Qid {
    pub path: uvlong,
    pub vers: ulong,
    pub type_: uchar,
}
#[test]
fn bindgen_test_layout_Qid() {
    assert_eq!(
        ::core::mem::size_of::<Qid>(),
        24usize,
        concat!("Size of: ", stringify!(Qid))
    );
    assert_eq!(
        ::core::mem::align_of::<Qid>(),
        8usize,
        concat!("Alignment of ", stringify!(Qid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qid>())).path as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Qid), "::", stringify!(path))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qid>())).vers as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Qid), "::", stringify!(vers))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Qid>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Qid),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dir {
    pub type_: ushort,
    pub dev: uint,
    pub qid: Qid,
    pub mode: ulong,
    pub atime: ulong,
    pub mtime: ulong,
    pub length: vlong,
    pub name: *mut ::std::os::raw::c_char,
    pub uid: *mut ::std::os::raw::c_char,
    pub gid: *mut ::std::os::raw::c_char,
    pub muid: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Dir() {
    assert_eq!(
        ::core::mem::size_of::<Dir>(),
        96usize,
        concat!("Size of: ", stringify!(Dir))
    );
    assert_eq!(
        ::core::mem::align_of::<Dir>(),
        8usize,
        concat!("Alignment of ", stringify!(Dir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dir),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).dev as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Dir), "::", stringify!(dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).qid as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Dir), "::", stringify!(qid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).mode as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(Dir), "::", stringify!(mode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).atime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Dir),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).mtime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Dir),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).length as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Dir),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).name as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(Dir), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).uid as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(Dir), "::", stringify!(uid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).gid as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(Dir), "::", stringify!(gid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dir>())).muid as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(Dir), "::", stringify!(muid))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OWaitmsg {
    pub pid: [::std::os::raw::c_char; 12usize],
    pub time: [::std::os::raw::c_char; 36usize],
    pub msg: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_OWaitmsg() {
    assert_eq!(
        ::core::mem::size_of::<OWaitmsg>(),
        112usize,
        concat!("Size of: ", stringify!(OWaitmsg))
    );
    assert_eq!(
        ::core::mem::align_of::<OWaitmsg>(),
        1usize,
        concat!("Alignment of ", stringify!(OWaitmsg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OWaitmsg>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OWaitmsg),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OWaitmsg>())).time as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OWaitmsg),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<OWaitmsg>())).msg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OWaitmsg),
            "::",
            stringify!(msg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Waitmsg {
    pub pid: ::std::os::raw::c_int,
    pub time: [ulong; 3usize],
    pub msg: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_Waitmsg() {
    assert_eq!(
        ::core::mem::size_of::<Waitmsg>(),
        160usize,
        concat!("Size of: ", stringify!(Waitmsg))
    );
    assert_eq!(
        ::core::mem::align_of::<Waitmsg>(),
        8usize,
        concat!("Alignment of ", stringify!(Waitmsg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitmsg>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Waitmsg),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitmsg>())).time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Waitmsg),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitmsg>())).msg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Waitmsg),
            "::",
            stringify!(msg)
        )
    );
}
extern "C" {
    pub static mut etext: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut edata: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut end: [::std::os::raw::c_char; 0usize];
}
pub type Mpl = u64int;
pub type Mreg = Mpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pcidev {
    _unused: [u8; 0],
}
pub type PTE = u64int;
pub type uintmem = u64int;
pub type Tval = vlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ureg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vctl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Lock {
    pub key: u32int,
    pub isilock: ::std::os::raw::c_int,
    pub __bindgen_anon_1: Lock__bindgen_ty_1,
    pub pc: uintptr,
    pub p: *mut Proc,
    pub m: *mut Mach,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Lock__bindgen_ty_1 {
    pub pl: Mpl,
    pub sr: Mreg,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Lock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<Lock__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(Lock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Lock__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Lock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Lock__bindgen_ty_1>())).pl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lock__bindgen_ty_1),
            "::",
            stringify!(pl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Lock__bindgen_ty_1>())).sr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lock__bindgen_ty_1),
            "::",
            stringify!(sr)
        )
    );
}
#[test]
fn bindgen_test_layout_Lock() {
    assert_eq!(
        ::core::mem::size_of::<Lock>(),
        40usize,
        concat!("Size of: ", stringify!(Lock))
    );
    assert_eq!(
        ::core::mem::align_of::<Lock>(),
        8usize,
        concat!("Alignment of ", stringify!(Lock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Lock>())).key as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Lock), "::", stringify!(key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Lock>())).isilock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Lock),
            "::",
            stringify!(isilock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Lock>())).pc as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Lock), "::", stringify!(pc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Lock>())).p as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Lock), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Lock>())).m as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(Lock), "::", stringify!(m))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Label {
    pub sp: uintptr,
    pub pc: uintptr,
}
#[test]
fn bindgen_test_layout_Label() {
    assert_eq!(
        ::core::mem::size_of::<Label>(),
        16usize,
        concat!("Size of: ", stringify!(Label))
    );
    assert_eq!(
        ::core::mem::align_of::<Label>(),
        8usize,
        concat!("Alignment of ", stringify!(Label))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Label>())).sp as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Label), "::", stringify!(sp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Label>())).pc as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Label), "::", stringify!(pc))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fxsave {
    pub fcw: u16int,
    pub fsw: u16int,
    pub ftw: u8int,
    pub zero: u8int,
    pub fop: u16int,
    pub rip: u64int,
    pub rdp: u64int,
    pub mxcsr: u32int,
    pub mxcsrmask: u32int,
    pub st: [uchar; 128usize],
    pub xmm: [uchar; 256usize],
    pub ign: [uchar; 96usize],
}
#[test]
fn bindgen_test_layout_Fxsave() {
    assert_eq!(
        ::core::mem::size_of::<Fxsave>(),
        512usize,
        concat!("Size of: ", stringify!(Fxsave))
    );
    assert_eq!(
        ::core::mem::align_of::<Fxsave>(),
        8usize,
        concat!("Alignment of ", stringify!(Fxsave))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).fcw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(fcw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).fsw as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(fsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).zero as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(zero)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).mxcsrmask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(mxcsrmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(st)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fxsave>())).ign as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(Fxsave),
            "::",
            stringify!(ign)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PFPU {
    pub fpustate: ::std::os::raw::c_int,
    pub fxsave: [uchar; 527usize],
    pub fpusave: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_PFPU() {
    assert_eq!(
        ::core::mem::size_of::<PFPU>(),
        544usize,
        concat!("Size of: ", stringify!(PFPU))
    );
    assert_eq!(
        ::core::mem::align_of::<PFPU>(),
        8usize,
        concat!("Alignment of ", stringify!(PFPU))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PFPU>())).fpustate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PFPU),
            "::",
            stringify!(fpustate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PFPU>())).fxsave as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PFPU),
            "::",
            stringify!(fxsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PFPU>())).fpusave as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(PFPU),
            "::",
            stringify!(fpusave)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PMMU {
    pub mmuptp: [*mut Page; 4usize],
}
#[test]
fn bindgen_test_layout_PMMU() {
    assert_eq!(
        ::core::mem::size_of::<PMMU>(),
        32usize,
        concat!("Size of: ", stringify!(PMMU))
    );
    assert_eq!(
        ::core::mem::align_of::<PMMU>(),
        8usize,
        concat!("Alignment of ", stringify!(PMMU))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PMMU>())).mmuptp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PMMU),
            "::",
            stringify!(mmuptp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PNOTIFY {}
#[test]
fn bindgen_test_layout_PNOTIFY() {
    assert_eq!(
        ::core::mem::size_of::<PNOTIFY>(),
        0usize,
        concat!("Size of: ", stringify!(PNOTIFY))
    );
    assert_eq!(
        ::core::mem::align_of::<PNOTIFY>(),
        1usize,
        concat!("Alignment of ", stringify!(PNOTIFY))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Asm {
    pub addr: uintmem,
    pub size: uintmem,
    pub type_: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
    pub next: *mut Asm,
    pub base: uintmem,
    pub limit: uintmem,
    pub kbase: uintptr,
}
#[test]
fn bindgen_test_layout_Asm() {
    assert_eq!(
        ::core::mem::size_of::<Asm>(),
        56usize,
        concat!("Size of: ", stringify!(Asm))
    );
    assert_eq!(
        ::core::mem::align_of::<Asm>(),
        8usize,
        concat!("Alignment of ", stringify!(Asm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Asm>())).addr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Asm), "::", stringify!(addr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Asm>())).size as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Asm), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Asm>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Asm),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Asm>())).location as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Asm),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Asm>())).next as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Asm), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Asm>())).base as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(Asm), "::", stringify!(base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Asm>())).limit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Asm),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Asm>())).kbase as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Asm),
            "::",
            stringify!(kbase)
        )
    );
}
extern "C" {
    pub static mut asmlist: *mut Asm;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Confmem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DevConf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fastcall {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mntcache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mntrpc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Timers {
    _unused: [u8; 0],
}
pub type Devgen = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut Chan,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut Dirtab,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut Dir,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ref {
    pub ref_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Ref() {
    assert_eq!(
        ::core::mem::size_of::<Ref>(),
        4usize,
        concat!("Size of: ", stringify!(Ref))
    );
    assert_eq!(
        ::core::mem::align_of::<Ref>(),
        4usize,
        concat!("Alignment of ", stringify!(Ref))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ref>())).ref_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ref), "::", stringify!(ref_))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rendez {
    pub p: *mut Proc,
}
#[test]
fn bindgen_test_layout_Rendez() {
    assert_eq!(
        ::core::mem::size_of::<Rendez>(),
        8usize,
        concat!("Size of: ", stringify!(Rendez))
    );
    assert_eq!(
        ::core::mem::align_of::<Rendez>(),
        8usize,
        concat!("Alignment of ", stringify!(Rendez))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Rendez>())).p as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Rendez), "::", stringify!(p))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QLock {
    pub use_: Lock,
    pub head: *mut Proc,
    pub tail: *mut Proc,
    pub locked: ::std::os::raw::c_int,
    pub qpc: uintptr,
}
#[test]
fn bindgen_test_layout_QLock() {
    assert_eq!(
        ::core::mem::size_of::<QLock>(),
        72usize,
        concat!("Size of: ", stringify!(QLock))
    );
    assert_eq!(
        ::core::mem::align_of::<QLock>(),
        8usize,
        concat!("Alignment of ", stringify!(QLock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QLock>())).use_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QLock),
            "::",
            stringify!(use_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QLock>())).head as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(QLock),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QLock>())).tail as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(QLock),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QLock>())).locked as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(QLock),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<QLock>())).qpc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(QLock),
            "::",
            stringify!(qpc)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RWlock {
    pub use_: Lock,
    pub head: *mut Proc,
    pub tail: *mut Proc,
    pub wpc: uintptr,
    pub wproc: *mut Proc,
    pub readers: ::std::os::raw::c_int,
    pub writer: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RWlock() {
    assert_eq!(
        ::core::mem::size_of::<RWlock>(),
        80usize,
        concat!("Size of: ", stringify!(RWlock))
    );
    assert_eq!(
        ::core::mem::align_of::<RWlock>(),
        8usize,
        concat!("Alignment of ", stringify!(RWlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RWlock>())).use_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RWlock),
            "::",
            stringify!(use_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RWlock>())).head as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RWlock),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RWlock>())).tail as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RWlock),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RWlock>())).wpc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RWlock),
            "::",
            stringify!(wpc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RWlock>())).wproc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RWlock),
            "::",
            stringify!(wproc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RWlock>())).readers as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RWlock),
            "::",
            stringify!(readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RWlock>())).writer as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(RWlock),
            "::",
            stringify!(writer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Alarms {
    pub head: *mut Proc,
}
#[test]
fn bindgen_test_layout_Alarms() {
    assert_eq!(
        ::core::mem::size_of::<Alarms>(),
        8usize,
        concat!("Size of: ", stringify!(Alarms))
    );
    assert_eq!(
        ::core::mem::align_of::<Alarms>(),
        8usize,
        concat!("Alignment of ", stringify!(Alarms))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Alarms>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Alarms),
            "::",
            stringify!(head)
        )
    );
}
pub const Aaccess: ::std::os::raw::c_uint = 0;
pub const Abind: ::std::os::raw::c_uint = 1;
pub const Atodir: ::std::os::raw::c_uint = 2;
pub const Aopen: ::std::os::raw::c_uint = 3;
pub const Amount: ::std::os::raw::c_uint = 4;
pub const Acreate: ::std::os::raw::c_uint = 5;
pub const Aremove: ::std::os::raw::c_uint = 6;
pub const COPEN: ::std::os::raw::c_uint = 1;
pub const CMSG: ::std::os::raw::c_uint = 2;
pub const CCEXEC: ::std::os::raw::c_uint = 8;
pub const CFREE: ::std::os::raw::c_uint = 16;
pub const CRCLOSE: ::std::os::raw::c_uint = 32;
pub const CCACHE: ::std::os::raw::c_uint = 128;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const BINTR: ::std::os::raw::c_uint = 1;
pub const Bipck: ::std::os::raw::c_uint = 4;
pub const Budpck: ::std::os::raw::c_uint = 8;
pub const Btcpck: ::std::os::raw::c_uint = 16;
pub const Bpktck: ::std::os::raw::c_uint = 32;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Block {
    pub next: *mut Block,
    pub list: *mut Block,
    pub rp: *mut uchar,
    pub wp: *mut uchar,
    pub lim: *mut uchar,
    pub base: *mut uchar,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Block)>,
    pub flag: ushort,
    pub checksum: ushort,
    pub magic: ulong,
}
#[test]
fn bindgen_test_layout_Block() {
    assert_eq!(
        ::core::mem::size_of::<Block>(),
        72usize,
        concat!("Size of: ", stringify!(Block))
    );
    assert_eq!(
        ::core::mem::align_of::<Block>(),
        8usize,
        concat!("Alignment of ", stringify!(Block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Block>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Block),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Block>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Block),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Block>())).rp as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Block), "::", stringify!(rp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Block>())).wp as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Block), "::", stringify!(wp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Block>())).lim as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Block),
            "::",
            stringify!(lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Block>())).base as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Block),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Block>())).free as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Block),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Block>())).flag as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Block),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Block>())).checksum as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(Block),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Block>())).magic as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Block),
            "::",
            stringify!(magic)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Chan {
    pub next: *mut Chan,
    pub link: *mut Chan,
    pub offset: vlong,
    pub devoffset: vlong,
    pub dev: *mut Dev,
    pub devno: uint,
    pub mode: ushort,
    pub flag: ushort,
    pub qid: Qid,
    pub fid: ::std::os::raw::c_int,
    pub iounit: ulong,
    pub umh: *mut Mhead,
    pub umc: *mut Chan,
    pub umqlock: QLock,
    pub uri: ::std::os::raw::c_int,
    pub dri: ::std::os::raw::c_int,
    pub dirrock: *mut uchar,
    pub nrock: ::std::os::raw::c_int,
    pub mrock: ::std::os::raw::c_int,
    pub rockqlock: QLock,
    pub ismtpt: ::std::os::raw::c_int,
    pub mc: *mut Mntcache,
    pub mux: *mut Mnt,
    pub __bindgen_anon_1: Chan__bindgen_ty_1,
    pub mchan: *mut Chan,
    pub mqid: Qid,
    pub path: *mut Path,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Chan__bindgen_ty_1 {
    pub aux: *mut ::core::ffi::c_void,
    pub pgrpid: Qid,
    pub mid: ulong,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_Chan__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<Chan__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(Chan__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Chan__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Chan__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan__bindgen_ty_1>())).aux as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan__bindgen_ty_1),
            "::",
            stringify!(aux)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan__bindgen_ty_1>())).pgrpid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan__bindgen_ty_1),
            "::",
            stringify!(pgrpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan__bindgen_ty_1>())).mid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan__bindgen_ty_1),
            "::",
            stringify!(mid)
        )
    );
}
#[test]
fn bindgen_test_layout_Chan() {
    assert_eq!(
        ::core::mem::size_of::<Chan>(),
        360usize,
        concat!("Size of: ", stringify!(Chan))
    );
    assert_eq!(
        ::core::mem::align_of::<Chan>(),
        8usize,
        concat!("Alignment of ", stringify!(Chan))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).devoffset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(devoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).dev as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(Chan), "::", stringify!(dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).devno as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(devno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).mode as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).flag as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).qid as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(Chan), "::", stringify!(qid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).fid as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(Chan), "::", stringify!(fid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).iounit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(iounit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).umh as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(Chan), "::", stringify!(umh))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).umc as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(Chan), "::", stringify!(umc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).umqlock as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(umqlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).uri as *const _ as usize },
        176usize,
        concat!("Offset of field: ", stringify!(Chan), "::", stringify!(uri))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).dri as *const _ as usize },
        180usize,
        concat!("Offset of field: ", stringify!(Chan), "::", stringify!(dri))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).dirrock as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(dirrock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).nrock as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(nrock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).mrock as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(mrock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).rockqlock as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(rockqlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).ismtpt as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(ismtpt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).mc as *const _ as usize },
        280usize,
        concat!("Offset of field: ", stringify!(Chan), "::", stringify!(mc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).mux as *const _ as usize },
        288usize,
        concat!("Offset of field: ", stringify!(Chan), "::", stringify!(mux))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).mchan as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(mchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).mqid as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(mqid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Chan>())).path as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(Chan),
            "::",
            stringify!(path)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Path {
    pub s: *mut ::std::os::raw::c_char,
    pub mtpt: *mut *mut Chan,
    pub len: ::std::os::raw::c_int,
    pub alen: ::std::os::raw::c_int,
    pub mlen: ::std::os::raw::c_int,
    pub malen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Path() {
    assert_eq!(
        ::core::mem::size_of::<Path>(),
        32usize,
        concat!("Size of: ", stringify!(Path))
    );
    assert_eq!(
        ::core::mem::align_of::<Path>(),
        8usize,
        concat!("Alignment of ", stringify!(Path))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Path>())).s as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Path), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Path>())).mtpt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Path),
            "::",
            stringify!(mtpt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Path>())).len as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Path), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Path>())).alen as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Path),
            "::",
            stringify!(alen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Path>())).mlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Path),
            "::",
            stringify!(mlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Path>())).malen as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Path),
            "::",
            stringify!(malen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dev {
    pub dc: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub reset: ::core::option::Option<unsafe extern "C" fn()>,
    pub init: ::core::option::Option<unsafe extern "C" fn()>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn()>,
    pub attach: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> *mut Chan,
    >,
    pub walk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Chan,
            arg2: *mut Chan,
            arg3: *mut *mut ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ) -> *mut Walkqid,
    >,
    pub stat: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Chan,
            arg2: *mut uchar,
            arg3: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_long,
    >,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Chan, arg2: ::std::os::raw::c_int) -> *mut Chan,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Chan,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_int,
        ),
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Chan)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Chan,
            arg2: *mut ::core::ffi::c_void,
            arg3: ::std::os::raw::c_long,
            arg4: vlong,
        ) -> ::std::os::raw::c_long,
    >,
    pub bread: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Chan,
            arg2: ::std::os::raw::c_long,
            arg3: vlong,
        ) -> *mut Block,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Chan,
            arg2: *mut ::core::ffi::c_void,
            arg3: ::std::os::raw::c_long,
            arg4: vlong,
        ) -> ::std::os::raw::c_long,
    >,
    pub bwrite: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Chan,
            arg2: *mut Block,
            arg3: vlong,
        ) -> ::std::os::raw::c_long,
    >,
    pub remove: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Chan)>,
    pub wstat: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Chan,
            arg2: *mut uchar,
            arg3: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_long,
    >,
    pub power: ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub config: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut DevConf,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_Dev() {
    assert_eq!(
        ::core::mem::size_of::<Dev>(),
        152usize,
        concat!("Size of: ", stringify!(Dev))
    );
    assert_eq!(
        ::core::mem::align_of::<Dev>(),
        8usize,
        concat!("Alignment of ", stringify!(Dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).dc as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Dev), "::", stringify!(dc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).name as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Dev), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).reset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).init as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Dev), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).shutdown as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).attach as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).walk as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(Dev), "::", stringify!(walk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).stat as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Dev), "::", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).open as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(Dev), "::", stringify!(open))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).create as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).close as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).read as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(Dev), "::", stringify!(read))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).bread as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(bread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).write as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).bwrite as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(bwrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).remove as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).wstat as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(wstat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).power as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(power)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dev>())).config as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Dev),
            "::",
            stringify!(config)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dirtab {
    pub name: [::std::os::raw::c_char; 28usize],
    pub qid: Qid,
    pub length: vlong,
    pub perm: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_Dirtab() {
    assert_eq!(
        ::core::mem::size_of::<Dirtab>(),
        72usize,
        concat!("Size of: ", stringify!(Dirtab))
    );
    assert_eq!(
        ::core::mem::align_of::<Dirtab>(),
        8usize,
        concat!("Alignment of ", stringify!(Dirtab))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dirtab>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dirtab),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dirtab>())).qid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Dirtab),
            "::",
            stringify!(qid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dirtab>())).length as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Dirtab),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dirtab>())).perm as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Dirtab),
            "::",
            stringify!(perm)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Walkqid {
    pub clone: *mut Chan,
    pub nqid: ::std::os::raw::c_int,
    pub qid: [Qid; 1usize],
}
#[test]
fn bindgen_test_layout_Walkqid() {
    assert_eq!(
        ::core::mem::size_of::<Walkqid>(),
        40usize,
        concat!("Size of: ", stringify!(Walkqid))
    );
    assert_eq!(
        ::core::mem::align_of::<Walkqid>(),
        8usize,
        concat!("Alignment of ", stringify!(Walkqid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Walkqid>())).clone as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Walkqid),
            "::",
            stringify!(clone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Walkqid>())).nqid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Walkqid),
            "::",
            stringify!(nqid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Walkqid>())).qid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Walkqid),
            "::",
            stringify!(qid)
        )
    );
}
pub const NSMAX: ::std::os::raw::c_uint = 1000;
pub const NSLOG: ::std::os::raw::c_uint = 7;
pub const NSCACHE: ::std::os::raw::c_uint = 128;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mntwalk {
    pub cddone: ::std::os::raw::c_int,
    pub mh: *mut Mhead,
    pub cm: *mut Mount,
}
#[test]
fn bindgen_test_layout_Mntwalk() {
    assert_eq!(
        ::core::mem::size_of::<Mntwalk>(),
        24usize,
        concat!("Size of: ", stringify!(Mntwalk))
    );
    assert_eq!(
        ::core::mem::align_of::<Mntwalk>(),
        8usize,
        concat!("Alignment of ", stringify!(Mntwalk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mntwalk>())).cddone as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mntwalk),
            "::",
            stringify!(cddone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mntwalk>())).mh as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Mntwalk),
            "::",
            stringify!(mh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mntwalk>())).cm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mntwalk),
            "::",
            stringify!(cm)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mount {
    pub mountid: ::std::os::raw::c_int,
    pub next: *mut Mount,
    pub head: *mut Mhead,
    pub copy: *mut Mount,
    pub order: *mut Mount,
    pub to: *mut Chan,
    pub mflag: ::std::os::raw::c_int,
    pub spec: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Mount() {
    assert_eq!(
        ::core::mem::size_of::<Mount>(),
        64usize,
        concat!("Size of: ", stringify!(Mount))
    );
    assert_eq!(
        ::core::mem::align_of::<Mount>(),
        8usize,
        concat!("Alignment of ", stringify!(Mount))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mount>())).mountid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mount),
            "::",
            stringify!(mountid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mount>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Mount),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mount>())).head as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mount),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mount>())).copy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Mount),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mount>())).order as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Mount),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mount>())).to as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(Mount), "::", stringify!(to))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mount>())).mflag as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Mount),
            "::",
            stringify!(mflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mount>())).spec as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Mount),
            "::",
            stringify!(spec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Mhead {
    pub lock: RWlock,
    pub from: *mut Chan,
    pub mount: *mut Mount,
    pub hash: *mut Mhead,
}
#[test]
fn bindgen_test_layout_Mhead() {
    assert_eq!(
        ::core::mem::size_of::<Mhead>(),
        104usize,
        concat!("Size of: ", stringify!(Mhead))
    );
    assert_eq!(
        ::core::mem::align_of::<Mhead>(),
        8usize,
        concat!("Alignment of ", stringify!(Mhead))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mhead>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mhead),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mhead>())).from as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Mhead),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mhead>())).mount as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Mhead),
            "::",
            stringify!(mount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mhead>())).hash as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Mhead),
            "::",
            stringify!(hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mnt {
    pub c: *mut Chan,
    pub rip: *mut Proc,
    pub queue: *mut Mntrpc,
    pub id: uint,
    pub list: *mut Mnt,
    pub flags: ::std::os::raw::c_int,
    pub msize: ::std::os::raw::c_int,
    pub version: *mut ::std::os::raw::c_char,
    pub q: *mut Queue,
}
#[test]
fn bindgen_test_layout_Mnt() {
    assert_eq!(
        ::core::mem::size_of::<Mnt>(),
        64usize,
        concat!("Size of: ", stringify!(Mnt))
    );
    assert_eq!(
        ::core::mem::align_of::<Mnt>(),
        8usize,
        concat!("Alignment of ", stringify!(Mnt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mnt>())).c as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Mnt), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mnt>())).rip as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Mnt), "::", stringify!(rip))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mnt>())).queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mnt),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mnt>())).id as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Mnt), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mnt>())).list as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(Mnt), "::", stringify!(list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mnt>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Mnt),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mnt>())).msize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Mnt),
            "::",
            stringify!(msize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mnt>())).version as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Mnt),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mnt>())).q as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Mnt), "::", stringify!(q))
    );
}
pub const NUser: ::std::os::raw::c_uint = 0;
pub const NExit: ::std::os::raw::c_uint = 1;
pub const NDebug: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Note {
    pub msg: [::std::os::raw::c_char; 128usize],
    pub flag: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Note() {
    assert_eq!(
        ::core::mem::size_of::<Note>(),
        132usize,
        concat!("Size of: ", stringify!(Note))
    );
    assert_eq!(
        ::core::mem::align_of::<Note>(),
        4usize,
        concat!("Alignment of ", stringify!(Note))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Note>())).msg as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Note), "::", stringify!(msg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Note>())).flag as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Note),
            "::",
            stringify!(flag)
        )
    );
}
pub const PG_NOFLUSH: ::std::os::raw::c_uint = 0;
pub const PG_TXTFLUSH: ::std::os::raw::c_uint = 1;
pub const PG_DATFLUSH: ::std::os::raw::c_uint = 2;
pub const PG_NEWCOL: ::std::os::raw::c_uint = 3;
pub const PG_MOD: ::std::os::raw::c_uint = 1;
pub const PG_REF: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Page {
    pub pa: uintptr,
    pub va: uintptr,
    pub daddr: ulong,
    pub ref_: ::std::os::raw::c_int,
    pub modref: uchar,
    pub color: uchar,
    pub lg2size: uchar,
    pub cachectl: [::std::os::raw::c_char; 32usize],
    pub image: *mut Image,
    pub next: *mut Page,
    pub prev: *mut Page,
    pub hash: *mut Page,
}
#[test]
fn bindgen_test_layout_Page() {
    assert_eq!(
        ::core::mem::size_of::<Page>(),
        96usize,
        concat!("Size of: ", stringify!(Page))
    );
    assert_eq!(
        ::core::mem::align_of::<Page>(),
        8usize,
        concat!("Alignment of ", stringify!(Page))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).pa as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Page), "::", stringify!(pa))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).va as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Page), "::", stringify!(va))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).daddr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(daddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).ref_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).modref as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(modref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).color as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).lg2size as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(lg2size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).cachectl as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(cachectl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).image as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).prev as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Page>())).hash as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Page),
            "::",
            stringify!(hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image {
    pub c: *mut Chan,
    pub qid: Qid,
    pub mqid: Qid,
    pub mchan: *mut Chan,
    pub dc: ::std::os::raw::c_int,
    pub s: *mut Segment,
    pub hash: *mut Image,
    pub next: *mut Image,
    pub notext: ::std::os::raw::c_int,
    pub color: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Image() {
    assert_eq!(
        ::core::mem::size_of::<Image>(),
        104usize,
        concat!("Size of: ", stringify!(Image))
    );
    assert_eq!(
        ::core::mem::align_of::<Image>(),
        8usize,
        concat!("Alignment of ", stringify!(Image))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Image>())).c as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Image), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Image>())).qid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(qid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Image>())).mqid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(mqid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Image>())).mchan as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(mchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Image>())).dc as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(Image), "::", stringify!(dc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Image>())).s as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(Image), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Image>())).hash as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Image>())).next as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Image>())).notext as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(notext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Image>())).color as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(color)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Pte {
    pub pages: [*mut Page; 256usize],
    pub first: *mut *mut Page,
    pub last: *mut *mut Page,
}
#[test]
fn bindgen_test_layout_Pte() {
    assert_eq!(
        ::core::mem::size_of::<Pte>(),
        2064usize,
        concat!("Size of: ", stringify!(Pte))
    );
    assert_eq!(
        ::core::mem::align_of::<Pte>(),
        8usize,
        concat!("Alignment of ", stringify!(Pte))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pte>())).pages as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Pte),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pte>())).first as *const _ as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(Pte),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pte>())).last as *const _ as usize },
        2056usize,
        concat!("Offset of field: ", stringify!(Pte), "::", stringify!(last))
    );
}
pub const SG_TYPE: ::std::os::raw::c_uint = 7;
pub const SG_TEXT: ::std::os::raw::c_uint = 0;
pub const SG_DATA: ::std::os::raw::c_uint = 1;
pub const SG_BSS: ::std::os::raw::c_uint = 2;
pub const SG_STACK: ::std::os::raw::c_uint = 3;
pub const SG_SHARED: ::std::os::raw::c_uint = 4;
pub const SG_PHYSICAL: ::std::os::raw::c_uint = 5;
pub const SG_CACHED: ::std::os::raw::c_uint = 16;
pub const SG_RONLY: ::std::os::raw::c_uint = 32;
pub const SG_CEXEC: ::std::os::raw::c_uint = 64;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Physseg {
    pub attr: ulong,
    pub name: *mut ::std::os::raw::c_char,
    pub pa: uintptr,
    pub size: usize_,
    pub pgalloc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Segment, arg2: uintptr) -> *mut Page,
    >,
    pub pgfree: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Page)>,
    pub lg2pgsize: uchar,
}
#[test]
fn bindgen_test_layout_Physseg() {
    assert_eq!(
        ::core::mem::size_of::<Physseg>(),
        56usize,
        concat!("Size of: ", stringify!(Physseg))
    );
    assert_eq!(
        ::core::mem::align_of::<Physseg>(),
        8usize,
        concat!("Alignment of ", stringify!(Physseg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Physseg>())).attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Physseg),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Physseg>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Physseg),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Physseg>())).pa as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Physseg),
            "::",
            stringify!(pa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Physseg>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Physseg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Physseg>())).pgalloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Physseg),
            "::",
            stringify!(pgalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Physseg>())).pgfree as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Physseg),
            "::",
            stringify!(pgfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Physseg>())).lg2pgsize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Physseg),
            "::",
            stringify!(lg2pgsize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sema {
    pub addr: *mut ::std::os::raw::c_int,
    pub waiting: ::std::os::raw::c_int,
    pub next: *mut Sema,
    pub prev: *mut Sema,
}
#[test]
fn bindgen_test_layout_Sema() {
    assert_eq!(
        ::core::mem::size_of::<Sema>(),
        32usize,
        concat!("Size of: ", stringify!(Sema))
    );
    assert_eq!(
        ::core::mem::align_of::<Sema>(),
        8usize,
        concat!("Alignment of ", stringify!(Sema))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sema>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sema),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sema>())).waiting as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sema),
            "::",
            stringify!(waiting)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sema>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Sema),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sema>())).prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Sema),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Segment {
    pub lk: QLock,
    pub steal: ushort,
    pub type_: ushort,
    pub color: ::std::os::raw::c_int,
    pub base: uintptr,
    pub top: uintptr,
    pub size: usize_,
    pub fstart: ulong,
    pub flen: ulong,
    pub lg2pgsize: uchar,
    pub flushme: ::std::os::raw::c_int,
    pub image: *mut Image,
    pub pseg: *mut Physseg,
    pub profile: *mut ulong,
    pub ptemapmem: uintptr,
    pub map: *mut *mut Pte,
    pub mapsize: ::std::os::raw::c_int,
    pub ssegmap: [*mut Pte; 16usize],
    pub semalock: Lock,
    pub sema: Sema,
}
#[test]
fn bindgen_test_layout_Segment() {
    assert_eq!(
        ::core::mem::size_of::<Segment>(),
        376usize,
        concat!("Size of: ", stringify!(Segment))
    );
    assert_eq!(
        ::core::mem::align_of::<Segment>(),
        8usize,
        concat!("Alignment of ", stringify!(Segment))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).lk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(lk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).steal as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(steal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).type_ as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).color as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).top as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).fstart as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(fstart)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).flen as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(flen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).lg2pgsize as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(lg2pgsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).flushme as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(flushme)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).image as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).pseg as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(pseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).profile as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).ptemapmem as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(ptemapmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).map as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).mapsize as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(mapsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).ssegmap as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(ssegmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).semalock as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(semalock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Segment>())).sema as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(Segment),
            "::",
            stringify!(sema)
        )
    );
}
pub const RENDLOG: ::std::os::raw::c_uint = 5;
pub const RENDHASH: ::std::os::raw::c_uint = 32;
pub const MNTLOG: ::std::os::raw::c_uint = 5;
pub const MNTHASH: ::std::os::raw::c_uint = 32;
pub const NFD: ::std::os::raw::c_uint = 100;
pub const PGHLOG: ::std::os::raw::c_uint = 9;
pub const PGHSIZE: ::std::os::raw::c_uint = 512;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Pgrp {
    pub noattach: ::std::os::raw::c_int,
    pub pgrpid: ulong,
    pub debug: QLock,
    pub ns: RWlock,
    pub mnthash: [*mut Mhead; 32usize],
}
#[test]
fn bindgen_test_layout_Pgrp() {
    assert_eq!(
        ::core::mem::size_of::<Pgrp>(),
        424usize,
        concat!("Size of: ", stringify!(Pgrp))
    );
    assert_eq!(
        ::core::mem::align_of::<Pgrp>(),
        8usize,
        concat!("Alignment of ", stringify!(Pgrp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pgrp>())).noattach as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Pgrp),
            "::",
            stringify!(noattach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pgrp>())).pgrpid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pgrp),
            "::",
            stringify!(pgrpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pgrp>())).debug as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Pgrp),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pgrp>())).ns as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(Pgrp), "::", stringify!(ns))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pgrp>())).mnthash as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Pgrp),
            "::",
            stringify!(mnthash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rgrp {
    pub rendhash: [*mut Proc; 32usize],
}
#[test]
fn bindgen_test_layout_Rgrp() {
    assert_eq!(
        ::core::mem::size_of::<Rgrp>(),
        256usize,
        concat!("Size of: ", stringify!(Rgrp))
    );
    assert_eq!(
        ::core::mem::align_of::<Rgrp>(),
        8usize,
        concat!("Alignment of ", stringify!(Rgrp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Rgrp>())).rendhash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rgrp),
            "::",
            stringify!(rendhash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Egrp {
    pub ent: *mut *mut Evalue,
    pub nent: ::std::os::raw::c_int,
    pub ment: ::std::os::raw::c_int,
    pub path: ulong,
    pub vers: ulong,
}
#[test]
fn bindgen_test_layout_Egrp() {
    assert_eq!(
        ::core::mem::size_of::<Egrp>(),
        32usize,
        concat!("Size of: ", stringify!(Egrp))
    );
    assert_eq!(
        ::core::mem::align_of::<Egrp>(),
        8usize,
        concat!("Alignment of ", stringify!(Egrp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Egrp>())).ent as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Egrp), "::", stringify!(ent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Egrp>())).nent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Egrp),
            "::",
            stringify!(nent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Egrp>())).ment as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Egrp),
            "::",
            stringify!(ment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Egrp>())).path as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Egrp),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Egrp>())).vers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Egrp),
            "::",
            stringify!(vers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Evalue {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub link: *mut Evalue,
    pub qid: Qid,
}
#[test]
fn bindgen_test_layout_Evalue() {
    assert_eq!(
        ::core::mem::size_of::<Evalue>(),
        56usize,
        concat!("Size of: ", stringify!(Evalue))
    );
    assert_eq!(
        ::core::mem::align_of::<Evalue>(),
        8usize,
        concat!("Alignment of ", stringify!(Evalue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evalue>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Evalue),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evalue>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Evalue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evalue>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Evalue),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evalue>())).link as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Evalue),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evalue>())).qid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Evalue),
            "::",
            stringify!(qid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fgrp {
    pub fd: *mut *mut Chan,
    pub nfd: ::std::os::raw::c_int,
    pub maxfd: ::std::os::raw::c_int,
    pub exceed: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Fgrp() {
    assert_eq!(
        ::core::mem::size_of::<Fgrp>(),
        24usize,
        concat!("Size of: ", stringify!(Fgrp))
    );
    assert_eq!(
        ::core::mem::align_of::<Fgrp>(),
        8usize,
        concat!("Alignment of ", stringify!(Fgrp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fgrp>())).fd as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Fgrp), "::", stringify!(fd))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fgrp>())).nfd as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Fgrp), "::", stringify!(nfd))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fgrp>())).maxfd as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Fgrp),
            "::",
            stringify!(maxfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Fgrp>())).exceed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Fgrp),
            "::",
            stringify!(exceed)
        )
    );
}
pub const DELTAFD: ::std::os::raw::c_uint = 20;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pallocpg {
    pub head: *mut Page,
    pub tail: *mut Page,
    pub count: ulong,
    pub freecount: ulong,
}
#[test]
fn bindgen_test_layout_Pallocpg() {
    assert_eq!(
        ::core::mem::size_of::<Pallocpg>(),
        32usize,
        concat!("Size of: ", stringify!(Pallocpg))
    );
    assert_eq!(
        ::core::mem::align_of::<Pallocpg>(),
        8usize,
        concat!("Alignment of ", stringify!(Pallocpg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pallocpg>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Pallocpg),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pallocpg>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pallocpg),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pallocpg>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Pallocpg),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pallocpg>())).freecount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Pallocpg),
            "::",
            stringify!(freecount)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Palloc {
    pub avail: [Pallocpg; 32usize],
    pub user: ulong,
    pub hash: [*mut Page; 512usize],
    pub hashlock: Lock,
    pub r: Rendez,
    pub pwait: QLock,
}
#[test]
fn bindgen_test_layout_Palloc() {
    assert_eq!(
        ::core::mem::size_of::<Palloc>(),
        5248usize,
        concat!("Size of: ", stringify!(Palloc))
    );
    assert_eq!(
        ::core::mem::align_of::<Palloc>(),
        8usize,
        concat!("Alignment of ", stringify!(Palloc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Palloc>())).avail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Palloc),
            "::",
            stringify!(avail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Palloc>())).user as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(Palloc),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Palloc>())).hash as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(Palloc),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Palloc>())).hashlock as *const _ as usize },
        5128usize,
        concat!(
            "Offset of field: ",
            stringify!(Palloc),
            "::",
            stringify!(hashlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Palloc>())).r as *const _ as usize },
        5168usize,
        concat!("Offset of field: ", stringify!(Palloc), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Palloc>())).pwait as *const _ as usize },
        5176usize,
        concat!(
            "Offset of field: ",
            stringify!(Palloc),
            "::",
            stringify!(pwait)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Waitq {
    pub w: Waitmsg,
    pub next: *mut Waitq,
}
#[test]
fn bindgen_test_layout_Waitq() {
    assert_eq!(
        ::core::mem::size_of::<Waitq>(),
        168usize,
        concat!("Size of: ", stringify!(Waitq))
    );
    assert_eq!(
        ::core::mem::align_of::<Waitq>(),
        8usize,
        concat!("Alignment of ", stringify!(Waitq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitq>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Waitq), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitq>())).next as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Waitq),
            "::",
            stringify!(next)
        )
    );
}
pub const Trelative: ::std::os::raw::c_uint = 0;
pub const Tperiodic: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Timer {
    pub tmode: ::std::os::raw::c_int,
    pub tns: vlong,
    pub tf: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Ureg, arg2: *mut Timer)>,
    pub ta: *mut ::core::ffi::c_void,
    pub tt: *mut Timers,
    pub tticks: Tval,
    pub twhen: Tval,
    pub tnext: *mut Timer,
}
#[test]
fn bindgen_test_layout_Timer() {
    assert_eq!(
        ::core::mem::size_of::<Timer>(),
        64usize,
        concat!("Size of: ", stringify!(Timer))
    );
    assert_eq!(
        ::core::mem::align_of::<Timer>(),
        8usize,
        concat!("Alignment of ", stringify!(Timer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Timer>())).tmode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Timer),
            "::",
            stringify!(tmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Timer>())).tns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Timer),
            "::",
            stringify!(tns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Timer>())).tf as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Timer), "::", stringify!(tf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Timer>())).ta as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Timer), "::", stringify!(ta))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Timer>())).tt as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(Timer), "::", stringify!(tt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Timer>())).tticks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Timer),
            "::",
            stringify!(tticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Timer>())).twhen as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Timer),
            "::",
            stringify!(twhen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Timer>())).tnext as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Timer),
            "::",
            stringify!(tnext)
        )
    );
}
pub const RFNAMEG: ::std::os::raw::c_uint = 1;
pub const RFENVG: ::std::os::raw::c_uint = 2;
pub const RFFDG: ::std::os::raw::c_uint = 4;
pub const RFNOTEG: ::std::os::raw::c_uint = 8;
pub const RFPROC: ::std::os::raw::c_uint = 16;
pub const RFMEM: ::std::os::raw::c_uint = 32;
pub const RFNOWAIT: ::std::os::raw::c_uint = 64;
pub const RFCNAMEG: ::std::os::raw::c_uint = 1024;
pub const RFCENVG: ::std::os::raw::c_uint = 2048;
pub const RFCFDG: ::std::os::raw::c_uint = 4096;
pub const RFREND: ::std::os::raw::c_uint = 8192;
pub const RFNOMNT: ::std::os::raw::c_uint = 16384;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const SSEG: ::std::os::raw::c_uint = 0;
pub const TSEG: ::std::os::raw::c_uint = 1;
pub const DSEG: ::std::os::raw::c_uint = 2;
pub const BSEG: ::std::os::raw::c_uint = 3;
pub const ESEG: ::std::os::raw::c_uint = 4;
pub const LSEG: ::std::os::raw::c_uint = 5;
pub const SEG1: ::std::os::raw::c_uint = 6;
pub const SEG2: ::std::os::raw::c_uint = 7;
pub const SEG3: ::std::os::raw::c_uint = 8;
pub const SEG4: ::std::os::raw::c_uint = 9;
pub const NSEG: ::std::os::raw::c_uint = 10;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const Dead: ::std::os::raw::c_uint = 0;
pub const Moribund: ::std::os::raw::c_uint = 1;
pub const Ready: ::std::os::raw::c_uint = 2;
pub const Scheding: ::std::os::raw::c_uint = 3;
pub const Running: ::std::os::raw::c_uint = 4;
pub const Queueing: ::std::os::raw::c_uint = 5;
pub const QueueingR: ::std::os::raw::c_uint = 6;
pub const QueueingW: ::std::os::raw::c_uint = 7;
pub const Wakeme: ::std::os::raw::c_uint = 8;
pub const Broken: ::std::os::raw::c_uint = 9;
pub const Stopped: ::std::os::raw::c_uint = 10;
pub const Rendezvous: ::std::os::raw::c_uint = 11;
pub const Waitrelease: ::std::os::raw::c_uint = 12;
pub const Proc_stopme: ::std::os::raw::c_uint = 1;
pub const Proc_exitme: ::std::os::raw::c_uint = 2;
pub const Proc_traceme: ::std::os::raw::c_uint = 3;
pub const Proc_exitbig: ::std::os::raw::c_uint = 4;
pub const Proc_tracesyscall: ::std::os::raw::c_uint = 5;
pub const TUser: ::std::os::raw::c_uint = 0;
pub const TSys: ::std::os::raw::c_uint = 1;
pub const TReal: ::std::os::raw::c_uint = 2;
pub const TCUser: ::std::os::raw::c_uint = 3;
pub const TCSys: ::std::os::raw::c_uint = 4;
pub const TCReal: ::std::os::raw::c_uint = 5;
pub const NERR: ::std::os::raw::c_uint = 64;
pub const NNOTE: ::std::os::raw::c_uint = 5;
pub const Npriq: ::std::os::raw::c_uint = 20;
pub const Nrq: ::std::os::raw::c_uint = 22;
pub const PriRelease: ::std::os::raw::c_uint = 20;
pub const PriEdf: ::std::os::raw::c_uint = 21;
pub const PriNormal: ::std::os::raw::c_uint = 10;
pub const PriExtra: ::std::os::raw::c_uint = 19;
pub const PriKproc: ::std::os::raw::c_uint = 13;
pub const PriRoot: ::std::os::raw::c_uint = 13;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schedq {
    pub head: *mut Proc,
    pub tail: *mut Proc,
    pub n: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Schedq() {
    assert_eq!(
        ::core::mem::size_of::<Schedq>(),
        24usize,
        concat!("Size of: ", stringify!(Schedq))
    );
    assert_eq!(
        ::core::mem::align_of::<Schedq>(),
        8usize,
        concat!("Alignment of ", stringify!(Schedq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Schedq>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Schedq),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Schedq>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Schedq),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Schedq>())).n as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Schedq), "::", stringify!(n))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Ar0 {
    pub i: uintptr,
    pub l: uintptr,
    pub p: uintptr,
    pub u: usize_,
    pub v: *mut ::core::ffi::c_void,
    pub vl: vlong,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Ar0() {
    assert_eq!(
        ::core::mem::size_of::<Ar0>(),
        8usize,
        concat!("Size of: ", stringify!(Ar0))
    );
    assert_eq!(
        ::core::mem::align_of::<Ar0>(),
        8usize,
        concat!("Alignment of ", stringify!(Ar0))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ar0>())).i as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ar0), "::", stringify!(i))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ar0>())).l as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ar0), "::", stringify!(l))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ar0>())).p as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ar0), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ar0>())).u as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ar0), "::", stringify!(u))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ar0>())).v as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ar0), "::", stringify!(v))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ar0>())).vl as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ar0), "::", stringify!(vl))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Proc {
    pub sched: Label,
    pub kstack: *mut ::std::os::raw::c_char,
    pub mach: *mut Mach,
    pub text: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub args: *mut ::std::os::raw::c_char,
    pub nargs: ::std::os::raw::c_int,
    pub rnext: *mut Proc,
    pub qnext: *mut Proc,
    pub qlock: *mut QLock,
    pub state: ::std::os::raw::c_int,
    pub psstate: *mut ::std::os::raw::c_char,
    pub seg: [*mut Segment; 10usize],
    pub seglock: QLock,
    pub pid: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
    pub ref_: ::std::os::raw::c_int,
    pub noteid: ::std::os::raw::c_int,
    pub pidhash: *mut Proc,
    pub exl: Lock,
    pub waitq: *mut Waitq,
    pub nchild: ::std::os::raw::c_int,
    pub nwait: ::std::os::raw::c_int,
    pub qwaitr: QLock,
    pub waitr: Rendez,
    pub parent: *mut Proc,
    pub pgrp: *mut Pgrp,
    pub egrp: *mut Egrp,
    pub fgrp: *mut Fgrp,
    pub rgrp: *mut Rgrp,
    pub closingfgrp: *mut Fgrp,
    pub parentpid: ::std::os::raw::c_int,
    pub time: [ulong; 6usize],
    pub kentry: uvlong,
    pub pcycles: vlong,
    pub insyscall: ::std::os::raw::c_int,
    pub debug: QLock,
    pub pdbg: *mut Proc,
    pub procmode: ulong,
    pub privatemem: ulong,
    pub hang: ::std::os::raw::c_int,
    pub procctl: ::std::os::raw::c_int,
    pub pc: uintptr,
    pub rlock: Lock,
    pub r: *mut Rendez,
    pub sleep: Rendez,
    pub notepending: ::std::os::raw::c_int,
    pub kp: ::std::os::raw::c_int,
    pub palarm: *mut Proc,
    pub alarm: ulong,
    pub newtlb: ::std::os::raw::c_int,
    pub rendtag: uintptr,
    pub rendval: uintptr,
    pub rendhash: *mut Proc,
    pub trend: *mut Rendez,
    pub tfn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
    >,
    pub kpfun: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    pub kparg: *mut ::core::ffi::c_void,
    pub scallnr: ::std::os::raw::c_int,
    pub arg: [uchar; 40usize],
    pub nerrlab: ::std::os::raw::c_int,
    pub errlab: [Label; 64usize],
    pub syserrstr: *mut ::std::os::raw::c_char,
    pub errstr: *mut ::std::os::raw::c_char,
    pub errbuf0: [::std::os::raw::c_char; 128usize],
    pub errbuf1: [::std::os::raw::c_char; 128usize],
    pub genbuf: [::std::os::raw::c_char; 128usize],
    pub slash: *mut Chan,
    pub dot: *mut Chan,
    pub note: [Note; 5usize],
    pub nnote: ::std::os::raw::c_short,
    pub notified: ::std::os::raw::c_short,
    pub lastnote: Note,
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut ::std::os::raw::c_char),
    >,
    pub lockwait: *mut Lock,
    pub lastlock: *mut Lock,
    pub lastilock: *mut Lock,
    pub wired: *mut Mach,
    pub mp: *mut Mach,
    pub nlocks: ::std::os::raw::c_int,
    pub delaysched: ulong,
    pub priority: ulong,
    pub basepri: ulong,
    pub fixedpri: ::std::os::raw::c_int,
    pub cpu: ulong,
    pub lastupdate: ulong,
    pub readytime: ulong,
    pub movetime: ulong,
    pub preempted: ::std::os::raw::c_int,
    pub edf: *mut Edf,
    pub trace: ::std::os::raw::c_int,
    pub qpc: uintptr,
    pub setargs: ::std::os::raw::c_int,
    pub ureg: *mut ::core::ffi::c_void,
    pub dbgreg: *mut ::core::ffi::c_void,
    pub color: ::std::os::raw::c_int,
    pub fc: *mut Fastcall,
    pub fcount: ::std::os::raw::c_int,
    pub syscalltrace: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Proc() {
    assert_eq!(
        ::core::mem::size_of::<Proc>(),
        3296usize,
        concat!("Size of: ", stringify!(Proc))
    );
    assert_eq!(
        ::core::mem::align_of::<Proc>(),
        8usize,
        concat!("Alignment of ", stringify!(Proc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).sched as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).kstack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(kstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).mach as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(mach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).text as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).user as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).args as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).nargs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(nargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).rnext as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(rnext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).qnext as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(qnext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).qlock as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(qlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).state as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).psstate as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(psstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).seg as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(seg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).seglock as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(seglock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).pid as *const _ as usize },
        256usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(pid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).index as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).ref_ as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).noteid as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(noteid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).pidhash as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(pidhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).exl as *const _ as usize },
        280usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(exl))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).waitq as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(waitq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).nchild as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(nchild)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).nwait as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(nwait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).qwaitr as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(qwaitr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).waitr as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(waitr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).parent as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).pgrp as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(pgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).egrp as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(egrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).fgrp as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(fgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).rgrp as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(rgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).closingfgrp as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(closingfgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).parentpid as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(parentpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).time as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).kentry as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(kentry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).pcycles as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(pcycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).insyscall as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(insyscall)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).debug as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).pdbg as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(pdbg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).procmode as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(procmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).privatemem as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(privatemem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).hang as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(hang)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).procctl as *const _ as usize },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(procctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).pc as *const _ as usize },
        648usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(pc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).rlock as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(rlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).r as *const _ as usize },
        696usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).sleep as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(sleep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).notepending as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(notepending)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).kp as *const _ as usize },
        716usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(kp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).palarm as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(palarm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).alarm as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(alarm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).newtlb as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(newtlb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).rendtag as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(rendtag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).rendval as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(rendval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).rendhash as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(rendhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).trend as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(trend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).tfn as *const _ as usize },
        776usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(tfn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).kpfun as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(kpfun)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).kparg as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(kparg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).scallnr as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(scallnr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).arg as *const _ as usize },
        804usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(arg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).nerrlab as *const _ as usize },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(nerrlab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).errlab as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(errlab)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).syserrstr as *const _ as usize },
        1872usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(syserrstr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).errstr as *const _ as usize },
        1880usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(errstr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).errbuf0 as *const _ as usize },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(errbuf0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).errbuf1 as *const _ as usize },
        2016usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(errbuf1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).genbuf as *const _ as usize },
        2144usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(genbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).slash as *const _ as usize },
        2272usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(slash)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).dot as *const _ as usize },
        2280usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(dot))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).note as *const _ as usize },
        2288usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(note)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).nnote as *const _ as usize },
        2948usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(nnote)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).notified as *const _ as usize },
        2950usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(notified)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).lastnote as *const _ as usize },
        2952usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(lastnote)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).notify as *const _ as usize },
        3088usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).lockwait as *const _ as usize },
        3096usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(lockwait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).lastlock as *const _ as usize },
        3104usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(lastlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).lastilock as *const _ as usize },
        3112usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(lastilock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).wired as *const _ as usize },
        3120usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(wired)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).mp as *const _ as usize },
        3128usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(mp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).nlocks as *const _ as usize },
        3136usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(nlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).delaysched as *const _ as usize },
        3144usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(delaysched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).priority as *const _ as usize },
        3152usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).basepri as *const _ as usize },
        3160usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(basepri)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).fixedpri as *const _ as usize },
        3168usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(fixedpri)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).cpu as *const _ as usize },
        3176usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(cpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).lastupdate as *const _ as usize },
        3184usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(lastupdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).readytime as *const _ as usize },
        3192usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(readytime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).movetime as *const _ as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(movetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).preempted as *const _ as usize },
        3208usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(preempted)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).edf as *const _ as usize },
        3216usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(edf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).trace as *const _ as usize },
        3224usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(trace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).qpc as *const _ as usize },
        3232usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(qpc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).setargs as *const _ as usize },
        3240usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(setargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).ureg as *const _ as usize },
        3248usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(ureg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).dbgreg as *const _ as usize },
        3256usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(dbgreg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).color as *const _ as usize },
        3264usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).fc as *const _ as usize },
        3272usize,
        concat!("Offset of field: ", stringify!(Proc), "::", stringify!(fc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).fcount as *const _ as usize },
        3280usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(fcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Proc>())).syscalltrace as *const _ as usize },
        3288usize,
        concat!(
            "Offset of field: ",
            stringify!(Proc),
            "::",
            stringify!(syscalltrace)
        )
    );
}
pub const PROCMAX: ::std::os::raw::c_uint = 2000;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Procalloc {
    pub ht: [*mut Proc; 128usize],
    pub arena: *mut Proc,
    pub free: *mut Proc,
}
#[test]
fn bindgen_test_layout_Procalloc() {
    assert_eq!(
        ::core::mem::size_of::<Procalloc>(),
        1040usize,
        concat!("Size of: ", stringify!(Procalloc))
    );
    assert_eq!(
        ::core::mem::align_of::<Procalloc>(),
        8usize,
        concat!("Alignment of ", stringify!(Procalloc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Procalloc>())).ht as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Procalloc),
            "::",
            stringify!(ht)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Procalloc>())).arena as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(Procalloc),
            "::",
            stringify!(arena)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Procalloc>())).free as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(Procalloc),
            "::",
            stringify!(free)
        )
    );
}
pub const PRINTSIZE: ::std::os::raw::c_uint = 256;
pub const NUMSIZE: ::std::os::raw::c_uint = 12;
pub const READSTR: ::std::os::raw::c_uint = 4000;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Execvals {
    pub entry: uvlong,
    pub textsize: ulong,
    pub datasize: ulong,
}
#[test]
fn bindgen_test_layout_Execvals() {
    assert_eq!(
        ::core::mem::size_of::<Execvals>(),
        24usize,
        concat!("Size of: ", stringify!(Execvals))
    );
    assert_eq!(
        ::core::mem::align_of::<Execvals>(),
        8usize,
        concat!("Alignment of ", stringify!(Execvals))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Execvals>())).entry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Execvals),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Execvals>())).textsize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Execvals),
            "::",
            stringify!(textsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Execvals>())).datasize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Execvals),
            "::",
            stringify!(datasize)
        )
    );
}
extern "C" {
    pub static mut conffile: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut configfile: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut cpuserver: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut eve: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut hostdomain: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut initcode: [uchar; 0usize];
}
extern "C" {
    pub static mut kbdbuttons: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut noteidalloc: Ref;
}
extern "C" {
    pub static mut nphysseg: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut nsyscall: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut palloc: Palloc;
}
extern "C" {
    pub static mut parseboothdr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Chan,
            arg2: ulong,
            arg3: *mut Execvals,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut physseg: [Physseg; 0usize];
}
extern "C" {
    pub static mut procalloc: Procalloc;
}
extern "C" {
    pub static mut qiomaxatomic: uint;
}
extern "C" {
    pub static mut statename: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut sysname: *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _bindgen_ty_17 {
    pub n: *mut ::std::os::raw::c_char,
    pub f: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Ar0, arg2: va_list)>,
    pub r: Ar0,
}
#[test]
fn bindgen_test_layout__bindgen_ty_17() {
    assert_eq!(
        ::core::mem::size_of::<_bindgen_ty_17>(),
        24usize,
        concat!("Size of: ", stringify!(_bindgen_ty_17))
    );
    assert_eq!(
        ::core::mem::align_of::<_bindgen_ty_17>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_17))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_17>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_17),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_17>())).f as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_17),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_17>())).r as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_17),
            "::",
            stringify!(r)
        )
    );
}
extern "C" {
    pub static mut systab: [_bindgen_ty_17; 0usize];
}
pub const LRESPROF: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Log {
    pub opens: ::std::os::raw::c_int,
    pub buf: *mut ::std::os::raw::c_char,
    pub end: *mut ::std::os::raw::c_char,
    pub rptr: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub nlog: ::std::os::raw::c_int,
    pub minread: ::std::os::raw::c_int,
    pub logmask: ::std::os::raw::c_int,
    pub readq: QLock,
    pub readr: Rendez,
}
#[test]
fn bindgen_test_layout_Log() {
    assert_eq!(
        ::core::mem::size_of::<Log>(),
        128usize,
        concat!("Size of: ", stringify!(Log))
    );
    assert_eq!(
        ::core::mem::align_of::<Log>(),
        8usize,
        concat!("Alignment of ", stringify!(Log))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Log>())).opens as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Log),
            "::",
            stringify!(opens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Log>())).buf as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Log), "::", stringify!(buf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Log>())).end as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Log), "::", stringify!(end))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Log>())).rptr as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Log), "::", stringify!(rptr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Log>())).len as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(Log), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Log>())).nlog as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(Log), "::", stringify!(nlog))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Log>())).minread as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Log),
            "::",
            stringify!(minread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Log>())).logmask as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Log),
            "::",
            stringify!(logmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Log>())).readq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Log),
            "::",
            stringify!(readq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Log>())).readr as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Log),
            "::",
            stringify!(readr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Logflag {
    pub name: *mut ::std::os::raw::c_char,
    pub mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Logflag() {
    assert_eq!(
        ::core::mem::size_of::<Logflag>(),
        16usize,
        concat!("Size of: ", stringify!(Logflag))
    );
    assert_eq!(
        ::core::mem::align_of::<Logflag>(),
        8usize,
        concat!("Alignment of ", stringify!(Logflag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Logflag>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Logflag),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Logflag>())).mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Logflag),
            "::",
            stringify!(mask)
        )
    );
}
pub const NCMDFIELD: ::std::os::raw::c_uint = 128;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cmdbuf {
    pub buf: *mut ::std::os::raw::c_char,
    pub f: *mut *mut ::std::os::raw::c_char,
    pub nf: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Cmdbuf() {
    assert_eq!(
        ::core::mem::size_of::<Cmdbuf>(),
        24usize,
        concat!("Size of: ", stringify!(Cmdbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<Cmdbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(Cmdbuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Cmdbuf>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cmdbuf),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Cmdbuf>())).f as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Cmdbuf), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Cmdbuf>())).nf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Cmdbuf),
            "::",
            stringify!(nf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cmdtab {
    pub index: ::std::os::raw::c_int,
    pub cmd: *mut ::std::os::raw::c_char,
    pub narg: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Cmdtab() {
    assert_eq!(
        ::core::mem::size_of::<Cmdtab>(),
        24usize,
        concat!("Size of: ", stringify!(Cmdtab))
    );
    assert_eq!(
        ::core::mem::align_of::<Cmdtab>(),
        8usize,
        concat!("Alignment of ", stringify!(Cmdtab))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Cmdtab>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cmdtab),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Cmdtab>())).cmd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Cmdtab),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Cmdtab>())).narg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Cmdtab),
            "::",
            stringify!(narg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysUart {
    pub name: *mut ::std::os::raw::c_char,
    pub pnp: ::core::option::Option<unsafe extern "C" fn() -> *mut Uart>,
    pub enable:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int)>,
    pub disable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart)>,
    pub kick: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart)>,
    pub dobreak:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int)>,
    pub baud: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub bits: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub parity: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub modemctl:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int)>,
    pub rts:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int)>,
    pub dtr:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int)>,
    pub status: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Uart,
            arg2: *mut ::core::ffi::c_void,
            arg3: ::std::os::raw::c_long,
            arg4: ::std::os::raw::c_long,
        ) -> ::std::os::raw::c_long,
    >,
    pub fifo:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int)>,
    pub power:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int)>,
    pub getc:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart) -> ::std::os::raw::c_int>,
    pub putc:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart, arg2: ::std::os::raw::c_int)>,
    pub poll: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Uart)>,
}
#[test]
fn bindgen_test_layout_PhysUart() {
    assert_eq!(
        ::core::mem::size_of::<PhysUart>(),
        152usize,
        concat!("Size of: ", stringify!(PhysUart))
    );
    assert_eq!(
        ::core::mem::align_of::<PhysUart>(),
        8usize,
        concat!("Alignment of ", stringify!(PhysUart))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).pnp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(pnp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).enable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).disable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).kick as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(kick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).dobreak as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(dobreak)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).baud as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(baud)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).bits as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).stop as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).parity as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(parity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).modemctl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(modemctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).rts as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(rts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).dtr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(dtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).status as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).fifo as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(fifo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).power as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(power)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).getc as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(getc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).putc as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(putc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PhysUart>())).poll as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysUart),
            "::",
            stringify!(poll)
        )
    );
}
pub const Stagesize: ::std::os::raw::c_uint = 2048;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Uart {
    pub regs: *mut ::core::ffi::c_void,
    pub saveregs: *mut ::core::ffi::c_void,
    pub name: *mut ::std::os::raw::c_char,
    pub freq: ulong,
    pub bits: ::std::os::raw::c_int,
    pub stop: ::std::os::raw::c_int,
    pub parity: ::std::os::raw::c_int,
    pub baud: ::std::os::raw::c_int,
    pub phys: *mut PhysUart,
    pub console: ::std::os::raw::c_int,
    pub special: ::std::os::raw::c_int,
    pub next: *mut Uart,
    pub type_: ::std::os::raw::c_int,
    pub dev: ::std::os::raw::c_int,
    pub opens: ::std::os::raw::c_int,
    pub enabled: ::std::os::raw::c_int,
    pub elist: *mut Uart,
    pub perr: ::std::os::raw::c_int,
    pub ferr: ::std::os::raw::c_int,
    pub oerr: ::std::os::raw::c_int,
    pub berr: ::std::os::raw::c_int,
    pub serr: ::std::os::raw::c_int,
    pub putc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Queue,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub iq: *mut Queue,
    pub oq: *mut Queue,
    pub rlock: Lock,
    pub istage: [uchar; 2048usize],
    pub iw: *mut uchar,
    pub ir: *mut uchar,
    pub ie: *mut uchar,
    pub tlock: Lock,
    pub ostage: [uchar; 2048usize],
    pub op: *mut uchar,
    pub oe: *mut uchar,
    pub drain: ::std::os::raw::c_int,
    pub modem: ::std::os::raw::c_int,
    pub xonoff: ::std::os::raw::c_int,
    pub blocked: ::std::os::raw::c_int,
    pub cts: ::std::os::raw::c_int,
    pub dsr: ::std::os::raw::c_int,
    pub dcd: ::std::os::raw::c_int,
    pub ctsbackoff: ::std::os::raw::c_int,
    pub hup_dsr: ::std::os::raw::c_int,
    pub hup_dcd: ::std::os::raw::c_int,
    pub dohup: ::std::os::raw::c_int,
    pub r: Rendez,
}
#[test]
fn bindgen_test_layout_Uart() {
    assert_eq!(
        ::core::mem::size_of::<Uart>(),
        4416usize,
        concat!("Size of: ", stringify!(Uart))
    );
    assert_eq!(
        ::core::mem::align_of::<Uart>(),
        8usize,
        concat!("Alignment of ", stringify!(Uart))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).saveregs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(saveregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).freq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).bits as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).stop as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).parity as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(parity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).baud as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(baud)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).phys as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).console as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(console)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).special as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(special)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).next as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).type_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).dev as *const _ as usize },
        76usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).opens as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(opens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).enabled as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).elist as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(elist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).perr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(perr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).ferr as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(ferr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).oerr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(oerr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).berr as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(berr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).serr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(serr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).putc as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(putc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).iq as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(iq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).oq as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(oq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).rlock as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(rlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).istage as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(istage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).iw as *const _ as usize },
        2232usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(iw))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).ir as *const _ as usize },
        2240usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(ir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).ie as *const _ as usize },
        2248usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(ie))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).tlock as *const _ as usize },
        2256usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(tlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).ostage as *const _ as usize },
        2296usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(ostage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).op as *const _ as usize },
        4344usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(op))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).oe as *const _ as usize },
        4352usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(oe))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).drain as *const _ as usize },
        4360usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(drain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).modem as *const _ as usize },
        4364usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(modem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).xonoff as *const _ as usize },
        4368usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(xonoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).blocked as *const _ as usize },
        4372usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(blocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).cts as *const _ as usize },
        4376usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(cts))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).dsr as *const _ as usize },
        4380usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(dsr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).dcd as *const _ as usize },
        4384usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(dcd))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).ctsbackoff as *const _ as usize },
        4388usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(ctsbackoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).hup_dsr as *const _ as usize },
        4392usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(hup_dsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).hup_dcd as *const _ as usize },
        4396usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(hup_dcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).dohup as *const _ as usize },
        4400usize,
        concat!(
            "Offset of field: ",
            stringify!(Uart),
            "::",
            stringify!(dohup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Uart>())).r as *const _ as usize },
        4408usize,
        concat!("Offset of field: ", stringify!(Uart), "::", stringify!(r))
    );
}
extern "C" {
    pub static mut consuart: *mut Uart;
}
extern "C" {
    pub static mut lprint: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Perf {
    pub intrts: ulong,
    pub inintr: ulong,
    pub avg_inintr: ulong,
    pub inidle: ulong,
    pub avg_inidle: ulong,
    pub last: ulong,
    pub period: ulong,
}
#[test]
fn bindgen_test_layout_Perf() {
    assert_eq!(
        ::core::mem::size_of::<Perf>(),
        56usize,
        concat!("Size of: ", stringify!(Perf))
    );
    assert_eq!(
        ::core::mem::align_of::<Perf>(),
        8usize,
        concat!("Alignment of ", stringify!(Perf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Perf>())).intrts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Perf),
            "::",
            stringify!(intrts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Perf>())).inintr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Perf),
            "::",
            stringify!(inintr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Perf>())).avg_inintr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Perf),
            "::",
            stringify!(avg_inintr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Perf>())).inidle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Perf),
            "::",
            stringify!(inidle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Perf>())).avg_inidle as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Perf),
            "::",
            stringify!(avg_inidle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Perf>())).last as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Perf),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Perf>())).period as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Perf),
            "::",
            stringify!(period)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Watchdog {
    pub enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub disable: ::core::option::Option<unsafe extern "C" fn()>,
    pub restart: ::core::option::Option<unsafe extern "C" fn()>,
    pub stat: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char, arg2: *mut ::std::os::raw::c_char),
    >,
}
#[test]
fn bindgen_test_layout_Watchdog() {
    assert_eq!(
        ::core::mem::size_of::<Watchdog>(),
        32usize,
        concat!("Size of: ", stringify!(Watchdog))
    );
    assert_eq!(
        ::core::mem::align_of::<Watchdog>(),
        8usize,
        concat!("Alignment of ", stringify!(Watchdog))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Watchdog>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Watchdog),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Watchdog>())).disable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Watchdog),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Watchdog>())).restart as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Watchdog),
            "::",
            stringify!(restart)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Watchdog>())).stat as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Watchdog),
            "::",
            stringify!(stat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Watermark {
    pub highwater: ::std::os::raw::c_int,
    pub curr: ::std::os::raw::c_int,
    pub max: ::std::os::raw::c_int,
    pub hitmax: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Watermark() {
    assert_eq!(
        ::core::mem::size_of::<Watermark>(),
        24usize,
        concat!("Size of: ", stringify!(Watermark))
    );
    assert_eq!(
        ::core::mem::align_of::<Watermark>(),
        8usize,
        concat!("Alignment of ", stringify!(Watermark))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Watermark>())).highwater as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Watermark),
            "::",
            stringify!(highwater)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Watermark>())).curr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Watermark),
            "::",
            stringify!(curr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Watermark>())).max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Watermark),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Watermark>())).hitmax as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Watermark),
            "::",
            stringify!(hitmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Watermark>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Watermark),
            "::",
            stringify!(name)
        )
    );
}
pub const Qstarve: ::std::os::raw::c_uint = 1;
pub const Qmsg: ::std::os::raw::c_uint = 2;
pub const Qclosed: ::std::os::raw::c_uint = 4;
pub const Qflow: ::std::os::raw::c_uint = 8;
pub const Qcoalesce: ::std::os::raw::c_uint = 16;
pub const Qkick: ::std::os::raw::c_uint = 32;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPU {
    pub cpuinfo: [[u32int; 4usize]; 2usize],
    pub ncpuinfos: ::std::os::raw::c_int,
    pub ncpuinfoe: ::std::os::raw::c_int,
    pub isintelcpu: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MCPU() {
    assert_eq!(
        ::core::mem::size_of::<MCPU>(),
        44usize,
        concat!("Size of: ", stringify!(MCPU))
    );
    assert_eq!(
        ::core::mem::align_of::<MCPU>(),
        4usize,
        concat!("Alignment of ", stringify!(MCPU))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPU>())).cpuinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPU),
            "::",
            stringify!(cpuinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPU>())).ncpuinfos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPU),
            "::",
            stringify!(ncpuinfos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPU>())).ncpuinfoe as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPU),
            "::",
            stringify!(ncpuinfoe)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MCPU>())).isintelcpu as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MCPU),
            "::",
            stringify!(isintelcpu)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MFPU {
    pub fcw: u16int,
    pub mxcsr: u32int,
    pub mxcsrmask: u32int,
}
#[test]
fn bindgen_test_layout_MFPU() {
    assert_eq!(
        ::core::mem::size_of::<MFPU>(),
        12usize,
        concat!("Size of: ", stringify!(MFPU))
    );
    assert_eq!(
        ::core::mem::align_of::<MFPU>(),
        4usize,
        concat!("Alignment of ", stringify!(MFPU))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MFPU>())).fcw as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(MFPU), "::", stringify!(fcw))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MFPU>())).mxcsr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MFPU),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MFPU>())).mxcsrmask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MFPU),
            "::",
            stringify!(mxcsrmask)
        )
    );
}
pub const NPGSZ: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMMU {
    pub pml4: *mut Page,
    pub pmap: *mut PTE,
    pub pgszlg2: [uint; 4usize],
    pub pgszmask: [uintmem; 4usize],
    pub pgsz: [uint; 4usize],
    pub npgsz: ::std::os::raw::c_int,
    pub pml4kludge: Page,
}
#[test]
fn bindgen_test_layout_MMMU() {
    assert_eq!(
        ::core::mem::size_of::<MMMU>(),
        184usize,
        concat!("Size of: ", stringify!(MMMU))
    );
    assert_eq!(
        ::core::mem::align_of::<MMMU>(),
        8usize,
        concat!("Alignment of ", stringify!(MMMU))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMMU>())).pml4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMMU),
            "::",
            stringify!(pml4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMMU>())).pmap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMMU),
            "::",
            stringify!(pmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMMU>())).pgszlg2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMMU),
            "::",
            stringify!(pgszlg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMMU>())).pgszmask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMMU),
            "::",
            stringify!(pgszmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMMU>())).pgsz as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MMMU),
            "::",
            stringify!(pgsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMMU>())).npgsz as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MMMU),
            "::",
            stringify!(npgsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MMMU>())).pml4kludge as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MMMU),
            "::",
            stringify!(pml4kludge)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Mach {
    pub machno: ::std::os::raw::c_int,
    pub splpc: uintptr,
    pub proc_: *mut Proc,
    pub apicno: ::std::os::raw::c_int,
    pub online: ::std::os::raw::c_int,
    pub mode: ::std::os::raw::c_int,
    pub stack: uintptr,
    pub vsvm: *mut uchar,
    pub gdt: *mut ::core::ffi::c_void,
    pub tss: *mut ::core::ffi::c_void,
    pub ticks: ulong,
    pub sched: Label,
    pub alarmlock: Lock,
    pub alarm: *mut ::core::ffi::c_void,
    pub inclockintr: ::std::os::raw::c_int,
    pub readied: *mut Proc,
    pub schedticks: ulong,
    pub color: ::std::os::raw::c_int,
    pub tlbfault: ::std::os::raw::c_int,
    pub tlbpurge: ::std::os::raw::c_int,
    pub pfault: ::std::os::raw::c_int,
    pub cs: ::std::os::raw::c_int,
    pub syscall: ::std::os::raw::c_int,
    pub load: ::std::os::raw::c_int,
    pub intr: ::std::os::raw::c_int,
    pub mmuflush: ::std::os::raw::c_int,
    pub ilockdepth: ::std::os::raw::c_int,
    pub ilockpc: uintptr,
    pub perf: Perf,
    pub lastintr: ::std::os::raw::c_int,
    pub apictimerlock: Lock,
    pub cyclefreq: uvlong,
    pub cpuhz: vlong,
    pub cpumhz: ::std::os::raw::c_int,
    pub rdtsc: u64int,
}
#[test]
fn bindgen_test_layout_Mach() {
    assert_eq!(
        ::core::mem::size_of::<Mach>(),
        352usize,
        concat!("Size of: ", stringify!(Mach))
    );
    assert_eq!(
        ::core::mem::align_of::<Mach>(),
        8usize,
        concat!("Alignment of ", stringify!(Mach))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).machno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(machno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).splpc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(splpc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).proc_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(proc_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).apicno as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(apicno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).online as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(online)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).mode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).stack as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).vsvm as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(vsvm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).gdt as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Mach), "::", stringify!(gdt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).tss as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(Mach), "::", stringify!(tss))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).ticks as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(ticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).sched as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).alarmlock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(alarmlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).alarm as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(alarm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).inclockintr as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(inclockintr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).readied as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(readied)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).schedticks as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(schedticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).color as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).tlbfault as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(tlbfault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).tlbpurge as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(tlbpurge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).pfault as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(pfault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).cs as *const _ as usize },
        184usize,
        concat!("Offset of field: ", stringify!(Mach), "::", stringify!(cs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).syscall as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(syscall)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).load as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).intr as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(intr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).mmuflush as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(mmuflush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).ilockdepth as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(ilockdepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).ilockpc as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(ilockpc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).perf as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(perf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).lastintr as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(lastintr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).apictimerlock as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(apictimerlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).cyclefreq as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(cyclefreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).cpuhz as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(cpuhz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).cpumhz as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(cpumhz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mach>())).rdtsc as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(Mach),
            "::",
            stringify!(rdtsc)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Sys {
    pub machstk: [uchar; 24576usize],
    pub pml4: [PTE; 512usize],
    pub pdp: [PTE; 512usize],
    pub pd: [PTE; 512usize],
    pub pt: [PTE; 512usize],
    pub vsvmpage: [uchar; 4096usize],
    pub __bindgen_anon_1: Sys__bindgen_ty_1,
    pub __bindgen_anon_2: Sys__bindgen_ty_2,
    pub __bindgen_anon_3: Sys__bindgen_ty_3,
    pub _57344_: [[uchar; 4096usize]; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Sys__bindgen_ty_1 {
    pub mach: Mach,
    pub machpage: [uchar; 4096usize],
    _bindgen_union_align: [u64; 512usize],
}
#[test]
fn bindgen_test_layout_Sys__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<Sys__bindgen_ty_1>(),
        4096usize,
        concat!("Size of: ", stringify!(Sys__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Sys__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Sys__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys__bindgen_ty_1>())).mach as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_1),
            "::",
            stringify!(mach)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys__bindgen_ty_1>())).machpage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_1),
            "::",
            stringify!(machpage)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Sys__bindgen_ty_2 {
    pub __bindgen_anon_1: Sys__bindgen_ty_2__bindgen_ty_1,
    pub syspage: [uchar; 4096usize],
    _bindgen_union_align: [u64; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sys__bindgen_ty_2__bindgen_ty_1 {
    pub pmstart: u64int,
    pub pmoccupied: u64int,
    pub pmend: u64int,
    pub pmpaged: u64int,
    pub vmstart: uintptr,
    pub vmunused: uintptr,
    pub vmunmapped: uintptr,
    pub vmend: uintptr,
    pub epoch: u64int,
    pub nmach: ::std::os::raw::c_int,
    pub nonline: ::std::os::raw::c_int,
    pub ticks: uint,
    pub copymode: uint,
}
#[test]
fn bindgen_test_layout_Sys__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<Sys__bindgen_ty_2__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(Sys__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Sys__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Sys__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).pmstart as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(pmstart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).pmoccupied as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(pmoccupied)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).pmend as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(pmend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).pmpaged as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(pmpaged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).vmstart as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(vmstart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).vmunused as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(vmunused)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).vmunmapped as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(vmunmapped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).vmend as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(vmend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).epoch as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(epoch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).nmach as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(nmach)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).nonline as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(nonline)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).ticks as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(ticks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Sys__bindgen_ty_2__bindgen_ty_1>())).copymode as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(copymode)
        )
    );
}
#[test]
fn bindgen_test_layout_Sys__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<Sys__bindgen_ty_2>(),
        4096usize,
        concat!("Size of: ", stringify!(Sys__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<Sys__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(Sys__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys__bindgen_ty_2>())).syspage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_2),
            "::",
            stringify!(syspage)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Sys__bindgen_ty_3 {
    pub machptr: [*mut Mach; 32usize],
    pub ptrpage: [uchar; 4096usize],
    _bindgen_union_align: [u64; 512usize],
}
#[test]
fn bindgen_test_layout_Sys__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<Sys__bindgen_ty_3>(),
        4096usize,
        concat!("Size of: ", stringify!(Sys__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<Sys__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(Sys__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys__bindgen_ty_3>())).machptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_3),
            "::",
            stringify!(machptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys__bindgen_ty_3>())).ptrpage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys__bindgen_ty_3),
            "::",
            stringify!(ptrpage)
        )
    );
}
#[test]
fn bindgen_test_layout_Sys() {
    assert_eq!(
        ::core::mem::size_of::<Sys>(),
        65536usize,
        concat!("Size of: ", stringify!(Sys))
    );
    assert_eq!(
        ::core::mem::align_of::<Sys>(),
        8usize,
        concat!("Alignment of ", stringify!(Sys))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys>())).machstk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys),
            "::",
            stringify!(machstk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys>())).pml4 as *const _ as usize },
        24576usize,
        concat!("Offset of field: ", stringify!(Sys), "::", stringify!(pml4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys>())).pdp as *const _ as usize },
        28672usize,
        concat!("Offset of field: ", stringify!(Sys), "::", stringify!(pdp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys>())).pd as *const _ as usize },
        32768usize,
        concat!("Offset of field: ", stringify!(Sys), "::", stringify!(pd))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys>())).pt as *const _ as usize },
        36864usize,
        concat!("Offset of field: ", stringify!(Sys), "::", stringify!(pt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys>())).vsvmpage as *const _ as usize },
        40960usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys),
            "::",
            stringify!(vsvmpage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sys>()))._57344_ as *const _ as usize },
        57344usize,
        concat!(
            "Offset of field: ",
            stringify!(Sys),
            "::",
            stringify!(_57344_)
        )
    );
}
extern "C" {
    pub static mut sys: *mut Sys;
}
pub type KMap = ::core::ffi::c_void;
extern "C" {
    pub fn kmap(arg1: *mut Page) -> *mut KMap;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_23 {
    pub machs: uint,
    pub exiting: ::std::os::raw::c_int,
    pub ispanic: ::std::os::raw::c_int,
    pub thunderbirdsarego: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_23() {
    assert_eq!(
        ::core::mem::size_of::<_bindgen_ty_23>(),
        16usize,
        concat!("Size of: ", stringify!(_bindgen_ty_23))
    );
    assert_eq!(
        ::core::mem::align_of::<_bindgen_ty_23>(),
        4usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_23))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_23>())).machs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_23),
            "::",
            stringify!(machs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_23>())).exiting as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_23),
            "::",
            stringify!(exiting)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_23>())).ispanic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_23),
            "::",
            stringify!(ispanic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_bindgen_ty_23>())).thunderbirdsarego as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_23),
            "::",
            stringify!(thunderbirdsarego)
        )
    );
}
extern "C" {
    pub static mut active: _bindgen_ty_23;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISAConf {
    pub type_: *mut ::std::os::raw::c_char,
    pub port: uintptr,
    pub irq: ::std::os::raw::c_int,
    pub dma: ulong,
    pub mem: uintptr,
    pub size: usize_,
    pub freq: ulong,
    pub nopt: ::std::os::raw::c_int,
    pub opt: [*mut ::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_ISAConf() {
    assert_eq!(
        ::core::mem::size_of::<ISAConf>(),
        128usize,
        concat!("Size of: ", stringify!(ISAConf))
    );
    assert_eq!(
        ::core::mem::align_of::<ISAConf>(),
        8usize,
        concat!("Alignment of ", stringify!(ISAConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ISAConf>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAConf),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ISAConf>())).port as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAConf),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ISAConf>())).irq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAConf),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ISAConf>())).dma as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAConf),
            "::",
            stringify!(dma)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ISAConf>())).mem as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAConf),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ISAConf>())).size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAConf),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ISAConf>())).freq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAConf),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ISAConf>())).nopt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAConf),
            "::",
            stringify!(nopt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ISAConf>())).opt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ISAConf),
            "::",
            stringify!(opt)
        )
    );
}
extern "C" {
    pub static mut kseg0: uintptr;
}
extern "C" {
    pub static mut dbgflg: [::std::os::raw::c_char; 256usize];
}
extern "C" {
    pub fn _assert(arg1: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn accounttime();
}
extern "C" {
    pub fn addbootfile(arg1: *mut ::std::os::raw::c_char, arg2: *mut uchar, arg3: ulong);
}
extern "C" {
    pub fn addclock0link(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::os::raw::c_int,
    ) -> *mut Timer;
}
extern "C" {
    pub fn addconsdev(
        arg1: *mut Queue,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int),
        >,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn addkbdq(arg1: *mut Queue, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn addphysseg(arg1: *mut Physseg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn addwatchdog(arg1: *mut Watchdog);
}
extern "C" {
    pub fn adec(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjustblock(arg1: *mut Block, arg2: ::std::os::raw::c_int) -> *mut Block;
}
extern "C" {
    pub fn ainc(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarmkproc(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn allocb(arg1: ::std::os::raw::c_int) -> *mut Block;
}
extern "C" {
    pub fn anyhigher() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn anyready() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn attachimage(
        arg1: ::std::os::raw::c_int,
        arg2: *mut Chan,
        arg3: ::std::os::raw::c_int,
        arg4: uintptr,
        arg5: uintptr,
    ) -> *mut Image;
}
extern "C" {
    pub fn auxpage(arg1: uint) -> *mut Page;
}
extern "C" {
    pub fn bl2mem(arg1: *mut uchar, arg2: *mut Block, arg3: ::std::os::raw::c_int) -> *mut Block;
}
extern "C" {
    pub fn blocklen(arg1: *mut Block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bootlinks();
}
extern "C" {
    pub fn cachedel(arg1: *mut Image, arg2: ulong);
}
extern "C" {
    pub fn cachepage(arg1: *mut Page, arg2: *mut Image);
}
extern "C" {
    pub fn callwithureg(arg1: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Ureg)>);
}
extern "C" {
    pub fn chanpath(arg1: *mut Chan) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn canlock(arg1: *mut Lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canpage(arg1: *mut Proc) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canqlock(arg1: *mut QLock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canrlock(arg1: *mut RWlock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cclone(arg1: *mut Chan) -> *mut Chan;
}
extern "C" {
    pub fn cclose(arg1: *mut Chan);
}
extern "C" {
    pub fn ccloseq(arg1: *mut Chan);
}
extern "C" {
    pub fn chanfree(arg1: *mut Chan);
}
extern "C" {
    pub fn checkalarms();
}
extern "C" {
    pub fn checkb(arg1: *mut Block, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn cinit();
}
extern "C" {
    pub fn closeegrp(arg1: *mut Egrp);
}
extern "C" {
    pub fn closefgrp(arg1: *mut Fgrp);
}
extern "C" {
    pub fn closepgrp(arg1: *mut Pgrp);
}
extern "C" {
    pub fn closergrp(arg1: *mut Rgrp);
}
extern "C" {
    pub fn cmderror(arg1: *mut Cmdbuf, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn cmount(
        arg1: *mut *mut Chan,
        arg2: *mut Chan,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn consactive() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut consdebug: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn concatblock(arg1: *mut Block) -> *mut Block;
}
extern "C" {
    pub static mut consputs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int),
    >;
}
extern "C" {
    pub fn copen(arg1: *mut Chan);
}
extern "C" {
    pub fn copyblock(arg1: *mut Block, arg2: ::std::os::raw::c_int) -> *mut Block;
}
extern "C" {
    pub fn copypage(arg1: *mut Page, arg2: *mut Page);
}
extern "C" {
    pub fn cread(
        arg1: *mut Chan,
        arg2: *mut uchar,
        arg3: ::std::os::raw::c_int,
        arg4: vlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cunmount(arg1: *mut Chan, arg2: *mut Chan);
}
extern "C" {
    pub fn cupdate(arg1: *mut Chan, arg2: *mut uchar, arg3: ::std::os::raw::c_int, arg4: vlong);
}
extern "C" {
    pub fn cwrite(arg1: *mut Chan, arg2: *mut uchar, arg3: ::std::os::raw::c_int, arg4: vlong);
}
extern "C" {
    pub fn dbgpc(arg1: *mut Proc) -> uintptr;
}
extern "C" {
    pub fn decrypt(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn delay(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn delconsdevs();
}
extern "C" {
    pub fn dequeueproc(arg1: *mut Schedq, arg2: *mut Proc) -> *mut Proc;
}
extern "C" {
    pub fn devattach(arg1: ::std::os::raw::c_int, arg2: *mut ::std::os::raw::c_char) -> *mut Chan;
}
extern "C" {
    pub fn devbread(arg1: *mut Chan, arg2: ::std::os::raw::c_long, arg3: vlong) -> *mut Block;
}
extern "C" {
    pub fn devbwrite(arg1: *mut Chan, arg2: *mut Block, arg3: vlong) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn devclone(arg1: *mut Chan) -> *mut Chan;
}
extern "C" {
    pub fn devconfig(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut DevConf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devcreate(
        arg1: *mut Chan,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn devdir(
        arg1: *mut Chan,
        arg2: Qid,
        arg3: *mut ::std::os::raw::c_char,
        arg4: vlong,
        arg5: *mut ::std::os::raw::c_char,
        arg6: ::std::os::raw::c_long,
        arg7: *mut Dir,
    );
}
extern "C" {
    pub fn devdirread(
        arg1: *mut Chan,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
        arg4: *mut Dirtab,
        arg5: ::std::os::raw::c_int,
        arg6: Devgen,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn devgen(
        arg1: *mut Chan,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut Dirtab,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: *mut Dir,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devinit();
}
extern "C" {
    pub fn devopen(
        arg1: *mut Chan,
        arg2: ::std::os::raw::c_int,
        arg3: *mut Dirtab,
        arg4: ::std::os::raw::c_int,
        arg5: Devgen,
    ) -> *mut Chan;
}
extern "C" {
    pub fn devpermcheck(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn devpower(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn devremove(arg1: *mut Chan);
}
extern "C" {
    pub fn devreset();
}
extern "C" {
    pub fn devshutdown();
}
extern "C" {
    pub fn devstat(
        arg1: *mut Chan,
        arg2: *mut uchar,
        arg3: ::std::os::raw::c_long,
        arg4: *mut Dirtab,
        arg5: ::std::os::raw::c_int,
        arg6: Devgen,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn devtabget(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> *mut Dev;
}
extern "C" {
    pub fn devtabinit();
}
extern "C" {
    pub fn devtabreset();
}
extern "C" {
    pub fn devtabread(
        arg1: *mut Chan,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_long,
        arg4: vlong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn devtabshutdown();
}
extern "C" {
    pub fn devwalk(
        arg1: *mut Chan,
        arg2: *mut Chan,
        arg3: *mut *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
        arg5: *mut Dirtab,
        arg6: ::std::os::raw::c_int,
        arg7: Devgen,
    ) -> *mut Walkqid;
}
extern "C" {
    pub fn devwstat(
        arg1: *mut Chan,
        arg2: *mut uchar,
        arg3: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drawactive(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn drawcmap();
}
extern "C" {
    pub fn dumpaproc(arg1: *mut Proc);
}
extern "C" {
    pub fn dumpregs(arg1: *mut Ureg);
}
extern "C" {
    pub fn dumpstack();
}
extern "C" {
    pub fn dupfgrp(arg1: *mut Fgrp) -> *mut Fgrp;
}
extern "C" {
    pub fn duppage(arg1: *mut Page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edfinit(arg1: *mut Proc);
}
extern "C" {
    pub fn edfadmit(arg1: *mut Proc) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn edfready(arg1: *mut Proc) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edfrecord(arg1: *mut Proc);
}
extern "C" {
    pub fn edfrun(arg1: *mut Proc, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn edfstop(arg1: *mut Proc);
}
extern "C" {
    pub fn edfyield();
}
extern "C" {
    pub fn emptystr(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encrypt(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn envcpy(arg1: *mut Egrp, arg2: *mut Egrp);
}
extern "C" {
    pub fn eqchanddq(
        arg1: *mut Chan,
        arg2: ::std::os::raw::c_int,
        arg3: uint,
        arg4: Qid,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eqqid(arg1: Qid, arg2: Qid) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn error(arg1: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn exhausted(arg1: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fastticks(arg1: *mut uvlong) -> uvlong;
}
extern "C" {
    pub fn fastticks2us(arg1: uvlong) -> uvlong;
}
extern "C" {
    pub fn fastticks2ns(arg1: uvlong) -> uvlong;
}
extern "C" {
    pub fn fault(arg1: uintptr, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdclose(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fdtochan(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut Chan;
}
extern "C" {
    pub fn findmount(
        arg1: *mut *mut Chan,
        arg2: *mut *mut Mhead,
        arg3: ::std::os::raw::c_int,
        arg4: uint,
        arg5: Qid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fixfault(
        arg1: *mut Segment,
        arg2: uintptr,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmtinit();
}
extern "C" {
    pub fn forceclosefgrp();
}
extern "C" {
    pub fn freeb(arg1: *mut Block);
}
extern "C" {
    pub fn freeblist(arg1: *mut Block);
}
extern "C" {
    pub fn freebroken() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freepte(arg1: *mut Segment, arg2: *mut Pte);
}
extern "C" {
    pub fn getcolor(arg1: ulong, arg2: *mut ulong, arg3: *mut ulong, arg4: *mut ulong);
}
extern "C" {
    pub fn gotolabel(arg1: *mut Label);
}
extern "C" {
    pub fn getconfenv() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn haswaitq(arg1: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hostdomainwrite(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn hostownerwrite(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn hzsched();
}
extern "C" {
    pub fn iallocb(arg1: ::std::os::raw::c_int) -> *mut Block;
}
extern "C" {
    pub fn ialloclimit(arg1: ulong);
}
extern "C" {
    pub fn iallocsummary();
}
extern "C" {
    pub fn ilock(arg1: *mut Lock);
}
extern "C" {
    pub fn iunlock(arg1: *mut Lock);
}
extern "C" {
    pub fn initimage();
}
extern "C" {
    pub fn initmark(
        arg1: *mut Watermark,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn iprint(arg1: *mut ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdir(arg1: *mut Chan);
}
extern "C" {
    pub fn iseve() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islo() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isoverlap(arg1: *mut Proc, arg2: uintptr, arg3: usize_) -> *mut Segment;
}
extern "C" {
    pub fn ispages(arg1: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isphysseg(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ixsummary();
}
extern "C" {
    pub fn kbdcr2nl(arg1: *mut Queue, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kbdgetmap(
        arg1: uint,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut Rune,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kbdputc(arg1: *mut Queue, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kbdputmap(arg1: ushort, arg2: ushort, arg3: Rune);
}
extern "C" {
    pub fn kickpager(arg1: uint, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn killbig(arg1: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn kproc(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn kprocchild(
        arg1: *mut Proc,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg3: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub static mut kproftimer: ::core::option::Option<unsafe extern "C" fn(arg1: uintptr)>;
}
extern "C" {
    pub fn ksetenv(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn kstrcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn kstrdup(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn l2be(arg1: ::std::os::raw::c_long) -> ulong;
}
extern "C" {
    pub fn latin1(arg1: *mut Rune, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lock(arg1: *mut Lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn logopen(arg1: *mut Log);
}
extern "C" {
    pub fn logclose(arg1: *mut Log);
}
extern "C" {
    pub fn logctl(
        arg1: *mut Log,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *mut ::std::os::raw::c_char,
        arg4: *mut Logflag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn logn(
        arg1: *mut Log,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::core::ffi::c_void,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn logread(
        arg1: *mut Log,
        arg2: *mut ::core::ffi::c_void,
        arg3: ulong,
        arg4: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn log(arg1: *mut Log, arg2: ::std::os::raw::c_int, arg3: *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn lookupcmd(
        arg1: *mut Cmdbuf,
        arg2: *mut Cmdtab,
        arg3: ::std::os::raw::c_int,
    ) -> *mut Cmdtab;
}
extern "C" {
    pub fn lookpage(arg1: *mut Image, arg2: ulong) -> *mut Page;
}
extern "C" {
    pub fn mallocinit();
}
extern "C" {
    pub fn mallocreadsummary(
        arg1: *mut Chan,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_long,
        arg4: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mallocsummary();
}
extern "C" {
    pub fn mem2bl(arg1: *mut uchar, arg2: ::std::os::raw::c_int) -> *mut Block;
}
extern "C" {
    pub fn mfreeseg(arg1: *mut Segment, arg2: uintptr, arg3: uintptr);
}
extern "C" {
    pub fn microdelay(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mk64fract(arg1: uvlong, arg2: uvlong) -> uvlong;
}
extern "C" {
    pub fn mkqid(arg1: *mut Qid, arg2: vlong, arg3: ulong, arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mmuflush();
}
extern "C" {
    pub fn mmuput(arg1: uintptr, arg2: uintptr, arg3: *mut Page);
}
extern "C" {
    pub fn mmurelease(arg1: *mut Proc);
}
extern "C" {
    pub fn mmuswitch(arg1: *mut Proc);
}
extern "C" {
    pub fn mntauth(arg1: *mut Chan, arg2: *mut ::std::os::raw::c_char) -> *mut Chan;
}
extern "C" {
    pub fn mntversion(
        arg1: *mut Chan,
        arg2: u32int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize_,
    ) -> usize_;
}
extern "C" {
    pub fn mountfree(arg1: *mut Mount);
}
extern "C" {
    pub fn mregfmt(arg1: *mut Fmt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ms2tk(arg1: ulong) -> ulong;
}
extern "C" {
    pub fn ms2fastticks(arg1: ulong) -> uvlong;
}
extern "C" {
    pub fn mul64fract(arg1: *mut uvlong, arg2: uvlong, arg3: uvlong);
}
extern "C" {
    pub fn muxclose(arg1: *mut Mnt);
}
extern "C" {
    pub fn namec(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut Chan;
}
extern "C" {
    pub fn nameerror(arg1: *mut ::std::os::raw::c_char, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn newchan() -> *mut Chan;
}
extern "C" {
    pub fn newfd(arg1: *mut Chan) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn newmhead(arg1: *mut Chan) -> *mut Mhead;
}
extern "C" {
    pub fn newmount(
        arg1: *mut Mhead,
        arg2: *mut Chan,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut Mount;
}
extern "C" {
    pub fn newpage(
        arg1: ::std::os::raw::c_int,
        arg2: *mut Segment,
        arg3: uintptr,
        arg4: uint,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> *mut Page;
}
extern "C" {
    pub fn newpath(arg1: *mut ::std::os::raw::c_char) -> *mut Path;
}
extern "C" {
    pub fn newpgrp() -> *mut Pgrp;
}
extern "C" {
    pub fn newrgrp() -> *mut Rgrp;
}
extern "C" {
    pub fn newproc() -> *mut Proc;
}
extern "C" {
    pub fn nexterror();
}
extern "C" {
    pub fn notemark(arg1: *mut Watermark, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nrand(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ns2fastticks(arg1: uvlong) -> uvlong;
}
extern "C" {
    pub fn okaddr(
        arg1: uintptr,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openmode(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn packblock(arg1: *mut Block) -> *mut Block;
}
extern "C" {
    pub fn padblock(arg1: *mut Block, arg2: ::std::os::raw::c_int) -> *mut Block;
}
extern "C" {
    pub fn pagechainhead(arg1: *mut Page);
}
extern "C" {
    pub fn pageinit();
}
extern "C" {
    pub fn pagenumber(arg1: *mut Page) -> ulong;
}
extern "C" {
    pub fn pagereclaim(arg1: ::std::os::raw::c_int) -> uvlong;
}
extern "C" {
    pub fn pageunchain(arg1: *mut Page);
}
extern "C" {
    pub fn panic(arg1: *mut ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn parsecmd(a: *mut ::std::os::raw::c_char, n: ::std::os::raw::c_int) -> *mut Cmdbuf;
}
extern "C" {
    pub fn pathclose(arg1: *mut Path);
}
extern "C" {
    pub fn perfticks() -> ulong;
}
extern "C" {
    pub fn pexit(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pgalloc(arg1: uint, arg2: ::std::os::raw::c_int) -> *mut Page;
}
extern "C" {
    pub fn pgfree(arg1: *mut Page);
}
extern "C" {
    pub fn pgrpcpy(arg1: *mut Pgrp, arg2: *mut Pgrp);
}
extern "C" {
    pub fn pgrpnote(
        arg1: ulong,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn physalloc(
        arg1: u64int,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut ::core::ffi::c_void,
    ) -> uintmem;
}
extern "C" {
    pub fn physdump();
}
extern "C" {
    pub fn physfree(arg1: uintmem, arg2: u64int);
}
extern "C" {
    pub fn physinit(arg1: uintmem, arg2: u64int);
}
extern "C" {
    pub fn phystag(arg1: uintmem) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn psindex(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pio(
        arg1: *mut Segment,
        arg2: uintptr,
        arg3: uintptr,
        arg4: *mut *mut Page,
        arg5: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn postnote(
        arg1: *mut Proc,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pprint(arg1: *mut ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn preempted() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn prflush();
}
extern "C" {
    pub fn printinit();
}
extern "C" {
    pub fn psinit();
}
extern "C" {
    pub fn procalarm(arg1: ulong) -> ulong;
}
extern "C" {
    pub fn procctl(arg1: *mut Proc);
}
extern "C" {
    pub fn procdump();
}
extern "C" {
    pub fn procfdprint(
        arg1: *mut Chan,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn procflushseg(arg1: *mut Segment);
}
extern "C" {
    pub fn procpriority(arg1: *mut Proc, arg2: ::std::os::raw::c_int, arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn procrestore(arg1: *mut Proc);
}
extern "C" {
    pub fn procsave(arg1: *mut Proc);
}
extern "C" {
    pub fn psincref(arg1: ::std::os::raw::c_int) -> *mut Proc;
}
extern "C" {
    pub fn psdecref(arg1: *mut Proc);
}
extern "C" {
    pub static mut proctrace: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Proc,
            arg2: ::std::os::raw::c_int,
            arg3: vlong,
            arg4: vlong,
        ),
    >;
}
extern "C" {
    pub fn procwired(arg1: *mut Proc, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ptealloc() -> *mut Pte;
}
extern "C" {
    pub fn ptecpy(arg1: *mut Pte) -> *mut Pte;
}
extern "C" {
    pub fn pullblock(arg1: *mut *mut Block, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pullupblock(arg1: *mut Block, arg2: ::std::os::raw::c_int) -> *mut Block;
}
extern "C" {
    pub fn pullupqueue(arg1: *mut Queue, arg2: ::std::os::raw::c_int) -> *mut Block;
}
extern "C" {
    pub fn putimage(arg1: *mut Image);
}
extern "C" {
    pub fn putmhead(arg1: *mut Mhead);
}
extern "C" {
    pub fn putpage(arg1: *mut Page);
}
extern "C" {
    pub fn putseg(arg1: *mut Segment);
}
extern "C" {
    pub fn putstrn(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pwait(arg1: *mut Waitmsg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qaddlist(arg1: *mut Queue, arg2: *mut Block);
}
extern "C" {
    pub fn qbread(arg1: *mut Queue, arg2: ::std::os::raw::c_int) -> *mut Block;
}
extern "C" {
    pub fn qbwrite(arg1: *mut Queue, arg2: *mut Block) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn qbypass(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut Block),
        >,
        arg2: *mut ::core::ffi::c_void,
    ) -> *mut Queue;
}
extern "C" {
    pub fn qcanread(arg1: *mut Queue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qclose(arg1: *mut Queue);
}
extern "C" {
    pub fn qconsume(
        arg1: *mut Queue,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qcopy(arg1: *mut Queue, arg2: ::std::os::raw::c_int, arg3: ulong) -> *mut Block;
}
extern "C" {
    pub fn qdiscard(arg1: *mut Queue, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qflush(arg1: *mut Queue);
}
extern "C" {
    pub fn qfree(arg1: *mut Queue);
}
extern "C" {
    pub fn qfull(arg1: *mut Queue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qget(arg1: *mut Queue) -> *mut Block;
}
extern "C" {
    pub fn qhangup(arg1: *mut Queue, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn qisclosed(arg1: *mut Queue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qiwrite(
        arg1: *mut Queue,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qlen(arg1: *mut Queue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qlock(arg1: *mut QLock);
}
extern "C" {
    pub fn qopen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg4: *mut ::core::ffi::c_void,
    ) -> *mut Queue;
}
extern "C" {
    pub fn qpass(arg1: *mut Queue, arg2: *mut Block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qpassnolim(arg1: *mut Queue, arg2: *mut Block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qproduce(
        arg1: *mut Queue,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qputback(arg1: *mut Queue, arg2: *mut Block);
}
extern "C" {
    pub fn qread(
        arg1: *mut Queue,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn qremove(arg1: *mut Queue) -> *mut Block;
}
extern "C" {
    pub fn qreopen(arg1: *mut Queue);
}
extern "C" {
    pub fn qsetlimit(arg1: *mut Queue, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn qunlock(arg1: *mut QLock);
}
extern "C" {
    pub fn qwindow(arg1: *mut Queue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qwrite(
        arg1: *mut Queue,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qnoblock(arg1: *mut Queue, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn randominit();
}
extern "C" {
    pub fn randomread(arg1: *mut ::core::ffi::c_void, arg2: ulong) -> ulong;
}
extern "C" {
    pub fn rdb();
}
extern "C" {
    pub fn readnum(
        arg1: ulong,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ulong,
        arg4: ulong,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readstr(
        arg1: ::std::os::raw::c_long,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ready(arg1: *mut Proc);
}
extern "C" {
    pub fn rebootcmd(arg1: ::std::os::raw::c_int, arg2: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn reboot(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn relocateseg(arg1: *mut Segment, arg2: uintptr);
}
extern "C" {
    pub fn renameuser(arg1: *mut ::std::os::raw::c_char, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn resched(arg1: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn resrcwait(arg1: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn return0(arg1: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rlock(arg1: *mut RWlock);
}
extern "C" {
    pub fn rtctime() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn runlock(arg1: *mut RWlock);
}
extern "C" {
    pub fn runproc() -> *mut Proc;
}
extern "C" {
    pub fn sched();
}
extern "C" {
    pub fn scheddump();
}
extern "C" {
    pub fn schedinit();
}
extern "C" {
    pub fn seconds() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn segclock(arg1: uintptr);
}
extern "C" {
    pub fn segpage(arg1: *mut Segment, arg2: *mut Page);
}
extern "C" {
    pub fn seprintmark(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut Watermark,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seprintpagestats(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seprintphysstats(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setcolor(arg1: ulong, arg2: ulong, arg3: ulong, arg4: ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkernur(arg1: *mut Ureg, arg2: *mut Proc);
}
extern "C" {
    pub fn setlabel(arg1: *mut Label) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregisters(
        arg1: *mut Ureg,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn skipslash(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sleep(
        arg1: *mut Rendez,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn smalloc(arg1: ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn srvname(arg1: *mut Chan) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn syscallfmt(arg1: ::std::os::raw::c_int, list: va_list);
}
extern "C" {
    pub fn sysretfmt(
        arg1: ::std::os::raw::c_int,
        arg2: va_list,
        arg3: *mut Ar0,
        arg4: uvlong,
        arg5: uvlong,
    );
}
extern "C" {
    pub fn sysrforkchild(arg1: *mut Proc, arg2: *mut Proc);
}
extern "C" {
    pub fn timeradd(arg1: *mut Timer);
}
extern "C" {
    pub fn timerdel(arg1: *mut Timer);
}
extern "C" {
    pub fn timersinit();
}
extern "C" {
    pub fn timerintr(arg1: *mut Ureg, arg2: vlong);
}
extern "C" {
    pub fn timerset(arg1: uvlong);
}
extern "C" {
    pub fn tk2ms(arg1: ulong) -> ulong;
}
extern "C" {
    pub fn tod2fastticks(arg1: vlong) -> uvlong;
}
extern "C" {
    pub fn todget(arg1: *mut vlong) -> vlong;
}
extern "C" {
    pub fn todsetfreq(arg1: vlong);
}
extern "C" {
    pub fn todinit();
}
extern "C" {
    pub fn todset(arg1: vlong, arg2: vlong, arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn tsleep(
        arg1: *mut Rendez,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::core::ffi::c_void,
        arg4: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn trimblock(
        arg1: *mut Block,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut Block;
}
extern "C" {
    pub fn uartconsole(arg1: ::std::os::raw::c_int, arg2: *mut ::std::os::raw::c_char)
        -> *mut Uart;
}
extern "C" {
    pub fn uartctl(arg1: *mut Uart, arg2: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uartgetc() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uartkick(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn uartmouse(
        arg1: *mut Uart,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Queue,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn uartsetmouseputc(
        arg1: *mut Uart,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Queue,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn uartputc(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn uartputs(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn uartrecv(arg1: *mut Uart, arg2: ::std::os::raw::c_char);
}
extern "C" {
    pub fn uartstageoutput(arg1: *mut Uart) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unbreak(arg1: *mut Proc);
}
extern "C" {
    pub fn uncachepage(arg1: *mut Page);
}
extern "C" {
    pub fn unlock(arg1: *mut Lock);
}
extern "C" {
    pub fn userinit();
}
extern "C" {
    pub fn userpc(arg1: *mut Ureg) -> uintptr;
}
extern "C" {
    pub fn userwrite(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn validaddr(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn validname(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn validnamedup(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn validstat(arg1: *mut uchar, arg2: usize_);
}
extern "C" {
    pub fn vmemchr(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn wakeup(arg1: *mut Rendez) -> *mut Proc;
}
extern "C" {
    pub fn walk(
        arg1: *mut *mut Chan,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wlock(arg1: *mut RWlock);
}
extern "C" {
    pub fn wunlock(arg1: *mut RWlock);
}
extern "C" {
    #[link_name = "\u{1}yield"]
    pub fn yield_();
}
extern "C" {
    pub fn data2txt(arg1: *mut Segment) -> *mut Segment;
}
extern "C" {
    pub fn dupseg(
        arg1: *mut *mut Segment,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut Segment;
}
extern "C" {
    pub fn newseg(arg1: ::std::os::raw::c_int, arg2: uintptr, arg3: uintptr) -> *mut Segment;
}
extern "C" {
    pub fn seg(arg1: *mut Proc, arg2: uintptr, arg3: ::std::os::raw::c_int) -> *mut Segment;
}
extern "C" {
    pub fn hnputv(arg1: *mut ::core::ffi::c_void, arg2: uvlong);
}
extern "C" {
    pub fn hnputl(arg1: *mut ::core::ffi::c_void, arg2: uint);
}
extern "C" {
    pub fn hnputs(arg1: *mut ::core::ffi::c_void, arg2: ushort);
}
extern "C" {
    pub fn nhgetv(arg1: *mut ::core::ffi::c_void) -> uvlong;
}
extern "C" {
    pub fn nhgetl(arg1: *mut ::core::ffi::c_void) -> uint;
}
extern "C" {
    pub fn nhgets(arg1: *mut ::core::ffi::c_void) -> ushort;
}
extern "C" {
    pub fn s() -> ulong;
}
extern "C" {
    pub fn aamloop(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn acpiinit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn addarchfile(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Chan,
                arg2: *mut ::core::ffi::c_void,
                arg3: ::std::os::raw::c_long,
                arg4: vlong,
            ) -> ::std::os::raw::c_long,
        >,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Chan,
                arg2: *mut ::core::ffi::c_void,
                arg3: ::std::os::raw::c_long,
                arg4: vlong,
            ) -> ::std::os::raw::c_long,
        >,
    ) -> *mut Dirtab;
}
extern "C" {
    pub fn archfmtinstall();
}
extern "C" {
    pub fn archinit();
}
extern "C" {
    pub fn archmmu() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn archreset();
}
extern "C" {
    pub fn archhz() -> vlong;
}
extern "C" {
    pub fn asmfree(
        arg1: uvlong,
        arg2: uvlong,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asmalloc(
        arg1: uvlong,
        arg2: uvlong,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> uvlong;
}
extern "C" {
    pub fn asminit();
}
extern "C" {
    pub fn asmmapinit(arg1: u64int, arg2: u64int, arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn asmmodinit(arg1: u32int, arg2: u32int, arg3: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn cgaconsputs(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cgainit();
}
extern "C" {
    pub fn cgapost(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub static mut coherence: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn corecolor(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpuid(arg1: u32int, arg2: u32int, arg3: *mut u32int) -> u32int;
}
extern "C" {
    pub fn fpudevprocio(
        arg1: *mut Proc,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_long,
        arg4: uintptr,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpuinit();
}
extern "C" {
    pub fn fpunoted();
}
extern "C" {
    pub fn fpunotify(arg1: *mut Ureg);
}
extern "C" {
    pub fn fpuprocrestore(arg1: *mut Proc);
}
extern "C" {
    pub fn fpuprocsave(arg1: *mut Proc);
}
extern "C" {
    pub fn fpusysprocsetup(arg1: *mut Proc);
}
extern "C" {
    pub fn fpusysrfork(arg1: *mut Ureg);
}
extern "C" {
    pub fn fpusysrforkchild(arg1: *mut Proc, arg2: *mut Proc);
}
extern "C" {
    pub fn getconf(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn halt();
}
extern "C" {
    pub fn i8042auxcmd(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i8042auxcmds(arg1: *mut uchar, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i8042auxenable(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int),
        >,
    );
}
extern "C" {
    pub fn i8042reset();
}
extern "C" {
    pub fn i8250console(arg1: *mut ::std::os::raw::c_char) -> *mut Uart;
}
extern "C" {
    pub fn i8250alloc(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn i8250mouse(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Queue,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn i8250setmouseputc(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Queue,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn i8254hz(arg1: *mut [u32int; 4usize]) -> vlong;
}
extern "C" {
    pub fn idlehands();
}
extern "C" {
    pub fn idthandlers();
}
extern "C" {
    pub fn inb(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn insb(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ins(arg1: ::std::os::raw::c_int) -> ushort;
}
extern "C" {
    pub fn inss(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn inl(arg1: ::std::os::raw::c_int) -> ulong;
}
extern "C" {
    pub fn insl(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn intrdisable(arg1: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intrenable(
        arg1: ::std::os::raw::c_int,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Ureg, arg2: *mut ::core::ffi::c_void),
        >,
        arg3: *mut ::core::ffi::c_void,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_char,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn invlpg(arg1: uintptr);
}
extern "C" {
    pub fn iofree(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ioinit();
}
extern "C" {
    pub fn iounused(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioalloc(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioreserve(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isaconfig(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ISAConf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kbdenable();
}
extern "C" {
    pub fn kbdinit();
}
extern "C" {
    pub fn kexit(arg1: *mut Ureg);
}
extern "C" {
    pub fn lfence();
}
extern "C" {
    pub fn links();
}
extern "C" {
    pub fn machinit();
}
extern "C" {
    pub fn mach0init();
}
extern "C" {
    pub fn mapraminit(arg1: uvlong, arg2: uvlong);
}
extern "C" {
    pub fn mapupainit(arg1: uvlong, arg2: ulong);
}
extern "C" {
    pub fn memcolor(arg1: uintmem, arg2: *mut uintmem) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn meminit();
}
extern "C" {
    pub fn mfence();
}
extern "C" {
    pub fn mmucachectl(arg1: *mut Page, arg2: uint);
}
extern "C" {
    pub fn mmuflushtlb(arg1: u64int);
}
extern "C" {
    pub fn mmuinit();
}
extern "C" {
    pub fn mmuphysaddr(arg1: uintptr) -> u64int;
}
extern "C" {
    pub fn mmuwalk(
        arg1: uintptr,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *mut PTE,
        arg4: ::core::option::Option<unsafe extern "C" fn(arg1: usize_) -> u64int>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn multiboot(
        arg1: u32int,
        arg2: u32int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ndnr();
}
extern "C" {
    pub fn nvramread(arg1: ::std::os::raw::c_int) -> uchar;
}
extern "C" {
    pub fn nvramwrite(arg1: ::std::os::raw::c_int, arg2: uchar);
}
extern "C" {
    pub fn optionsinit(arg1: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn outb(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn outsb(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn outs(arg1: ::std::os::raw::c_int, arg2: ushort);
}
extern "C" {
    pub fn outss(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn outl(arg1: ::std::os::raw::c_int, arg2: ulong);
}
extern "C" {
    pub fn outsl(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pause();
}
extern "C" {
    pub fn pciscan(arg1: ::std::os::raw::c_int, arg2: *mut *mut Pcidev) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcibarsize(arg1: *mut Pcidev, arg2: ::std::os::raw::c_int) -> ulong;
}
extern "C" {
    pub fn pcicap(arg1: *mut Pcidev, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcihtcap(arg1: *mut Pcidev, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcienumcaps(
        arg1: *mut Pcidev,
        fmatch: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Pcidev,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcicfgr8(arg1: *mut Pcidev, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcicfgr16(arg1: *mut Pcidev, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcicfgr32(arg1: *mut Pcidev, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcicfgw8(arg1: *mut Pcidev, arg2: ::std::os::raw::c_int, arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pcicfgw16(arg1: *mut Pcidev, arg2: ::std::os::raw::c_int, arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pcicfgw32(arg1: *mut Pcidev, arg2: ::std::os::raw::c_int, arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pciclrbme(arg1: *mut Pcidev);
}
extern "C" {
    pub fn pciclrioe(arg1: *mut Pcidev);
}
extern "C" {
    pub fn pciclrmwi(arg1: *mut Pcidev);
}
extern "C" {
    pub fn pcigetpms(arg1: *mut Pcidev) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcihinv(arg1: *mut Pcidev);
}
extern "C" {
    pub fn pciipin(arg1: *mut Pcidev, arg2: uchar) -> uchar;
}
extern "C" {
    pub fn pcimatch(
        arg1: *mut Pcidev,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> *mut Pcidev;
}
extern "C" {
    pub fn pcimatchtbdf(arg1: ::std::os::raw::c_int) -> *mut Pcidev;
}
extern "C" {
    pub fn pcireset();
}
extern "C" {
    pub fn pcisetbme(arg1: *mut Pcidev);
}
extern "C" {
    pub fn pcisetioe(arg1: *mut Pcidev);
}
extern "C" {
    pub fn pcisetmwi(arg1: *mut Pcidev);
}
extern "C" {
    pub fn pcisetpms(arg1: *mut Pcidev, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut pmcupdate: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn printcpufreq();
}
extern "C" {
    pub fn screenprint(arg1: *mut ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sfence();
}
extern "C" {
    pub fn spldone();
}
extern "C" {
    pub fn splhi() -> u64int;
}
extern "C" {
    pub fn spllo() -> u64int;
}
extern "C" {
    pub fn splx(arg1: u64int);
}
extern "C" {
    pub fn splxpc(arg1: u64int);
}
extern "C" {
    pub fn syncclock();
}
extern "C" {
    pub fn sysexecregs(arg1: uintptr, arg2: ulong, arg3: ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn sysexecstack(arg1: uintptr, arg2: ::std::os::raw::c_int) -> uintptr;
}
extern "C" {
    pub fn sysprocsetup(arg1: *mut Proc);
}
extern "C" {
    pub fn tssrsp0(arg1: u64int);
}
extern "C" {
    pub fn trapenable(
        arg1: ::std::os::raw::c_int,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Ureg, arg2: *mut ::core::ffi::c_void),
        >,
        arg3: *mut ::core::ffi::c_void,
        arg4: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn trapinit();
}
extern "C" {
    pub fn userureg(arg1: *mut Ureg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umeminit();
}
extern "C" {
    pub fn vmap(arg1: uintmem, arg2: usize_) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn vsvminit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn vunmap(arg1: *mut ::core::ffi::c_void, arg2: usize_);
}
extern "C" {
    pub static mut waitfor: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn cr0get() -> Mreg;
}
extern "C" {
    pub fn cr0put(arg1: Mreg);
}
extern "C" {
    pub fn cr2get() -> Mreg;
}
extern "C" {
    pub fn cr3get() -> Mreg;
}
extern "C" {
    pub fn cr3put(arg1: Mreg);
}
extern "C" {
    pub fn cr4get() -> Mreg;
}
extern "C" {
    pub fn cr4put(arg1: Mreg);
}
extern "C" {
    pub fn gdtget(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn gdtput(arg1: ::std::os::raw::c_int, arg2: u64int, arg3: u16int);
}
extern "C" {
    pub fn idtput(arg1: ::std::os::raw::c_int, arg2: u64int);
}
extern "C" {
    pub fn rdmsr(arg1: u32int) -> u64int;
}
extern "C" {
    pub fn rdtsc() -> u64int;
}
extern "C" {
    pub fn trput(arg1: u64int);
}
extern "C" {
    pub fn wrmsr(arg1: u32int, arg2: u64int);
}
extern "C" {
    pub fn cas32(
        arg1: *mut ::core::ffi::c_void,
        arg2: u32int,
        arg3: u32int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cas64(
        arg1: *mut ::core::ffi::c_void,
        arg2: u64int,
        arg3: u64int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tas32(arg1: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn touser(arg1: uintptr);
}
extern "C" {
    pub fn syscallentry();
}
extern "C" {
    pub fn syscallreturn();
}
extern "C" {
    pub fn sysrforkret();
}
extern "C" {
    pub fn KADDR(arg1: uintptr) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn PADDR(arg1: *mut ::core::ffi::c_void) -> uintptr;
}
extern "C" {
    pub fn apiceoi(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn apicinit(arg1: ::std::os::raw::c_int, arg2: uintptr, arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn apicisr(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn apiconline() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn apicsipi(arg1: ::std::os::raw::c_int, arg2: uintptr);
}
extern "C" {
    pub fn apictimerdisable();
}
extern "C" {
    pub fn apictimerenable();
}
extern "C" {
    pub fn apictimerintr(arg1: *mut Ureg, arg2: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn apictprput(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ioapicinit(arg1: ::std::os::raw::c_int, arg2: uintmem);
}
extern "C" {
    pub fn ioapicintrinit(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: u32int,
    );
}
extern "C" {
    pub fn ioapiconline();
}
extern "C" {
    pub fn millidelay(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn i8259init(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i8259irqdisable(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i8259irqenable(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i8259isr(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpsinit();
}
extern "C" {
    pub fn mpacpi();
}
extern "C" {
    pub fn sipi();
}
pub const Maxsteps: ::std::os::raw::c_ulong = 40000;
pub const Admitted: ::std::os::raw::c_ulong = 1;
pub const Sporadic: ::std::os::raw::c_ulong = 2;
pub const Yieldonblock: ::std::os::raw::c_ulong = 4;
pub const Sendnotes: ::std::os::raw::c_ulong = 8;
pub const Deadline: ::std::os::raw::c_ulong = 16;
pub const Yield: ::std::os::raw::c_ulong = 32;
pub const Extratime: ::std::os::raw::c_ulong = 64;
pub const Infinity: ::std::os::raw::c_ulong = 18446744073709551615;
pub type _bindgen_ty_24 = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Edf {
    pub D: ::std::os::raw::c_long,
    pub Delta: ::std::os::raw::c_long,
    pub T: ::std::os::raw::c_long,
    pub C: ::std::os::raw::c_long,
    pub S: ::std::os::raw::c_long,
    pub r: ::std::os::raw::c_long,
    pub d: ::std::os::raw::c_long,
    pub t: ::std::os::raw::c_long,
    pub s: ::std::os::raw::c_long,
    pub testDelta: ::std::os::raw::c_long,
    pub testtype: ::std::os::raw::c_int,
    pub testtime: ::std::os::raw::c_long,
    pub testnext: *mut Proc,
    pub flags: ushort,
    pub edfused: ::std::os::raw::c_long,
    pub extraused: ::std::os::raw::c_long,
    pub aged: ::std::os::raw::c_long,
    pub periods: ulong,
    pub missed: ulong,
}
#[test]
fn bindgen_test_layout_Edf() {
    assert_eq!(
        ::core::mem::size_of::<Edf>(),
        152usize,
        concat!("Size of: ", stringify!(Edf))
    );
    assert_eq!(
        ::core::mem::align_of::<Edf>(),
        8usize,
        concat!("Alignment of ", stringify!(Edf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).D as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Edf), "::", stringify!(D))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).Delta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Edf),
            "::",
            stringify!(Delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).T as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Edf), "::", stringify!(T))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).C as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Edf), "::", stringify!(C))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).S as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(Edf), "::", stringify!(S))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).r as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(Edf), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).d as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(Edf), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).t as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Edf), "::", stringify!(t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).s as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(Edf), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).testDelta as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Edf),
            "::",
            stringify!(testDelta)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).testtype as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Edf),
            "::",
            stringify!(testtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).testtime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Edf),
            "::",
            stringify!(testtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).testnext as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Edf),
            "::",
            stringify!(testnext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).flags as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Edf),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).edfused as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Edf),
            "::",
            stringify!(edfused)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).extraused as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Edf),
            "::",
            stringify!(extraused)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).aged as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(Edf), "::", stringify!(aged))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).periods as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Edf),
            "::",
            stringify!(periods)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Edf>())).missed as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Edf),
            "::",
            stringify!(missed)
        )
    );
}
extern "C" {
    pub static mut edftestlock: Lock;
}
extern "C" {
    pub fn edflock(arg1: *mut Proc) -> *mut Edf;
}
extern "C" {
    pub fn edfunlock();
}
